{
  "timestamp": "2025-10-08T07:25:00.521581",
  "python_version": "3.11.2 (main, Apr 28 2025, 14:11:48) [GCC 12.2.0]",
  "project_root": "/home/lighthouse/crypto_ai_trading",
  "test_discovery": {
    "contract_tests": {
      "path": "tests/contract",
      "description": "API端点合约测试",
      "exists": true,
      "test_files_count": 5,
      "test_files": [
        "test_order_execution.py",
        "test_strategy_generation.py",
        "test_long_analysis.py",
        "test_short_analysis.py",
        "test_news.py"
      ],
      "test_content": {
        "total_lines": 1975,
        "test_methods": [
          "def test_order_execution_endpoint_exists(self, async_test_client: TestClient):",
          "def test_order_execution_endpoint_method_not_allowed(self, async_test_client: TestClient):",
          "def test_order_execution_request_structure_validation(self, async_test_client: TestClient):",
          "def test_order_execution_required_fields(self, async_test_client: TestClient):",
          "def test_order_execution_valid_request_structure(self, async_test_client: TestClient):",
          "def test_order_execution_field_validation(self, async_test_client: TestClient, field, value):",
          "def test_order_execution_response_format_on_success(self, async_test_client: TestClient):",
          "def test_order_execution_error_response_format(self, async_test_client: TestClient):",
          "def test_order_execution_concurrent_requests(self, async_test_client: TestClient):",
          "def test_order_execution_request_size_limits(self, async_test_client: TestClient):",
          "def test_order_execution_content_type(self, async_test_client: TestClient):",
          "def test_order_execution_response_time(self, async_test_client: TestClient):",
          "def test_order_execution_symbol_formats(self, async_test_client: TestClient):",
          "def test_order_execution_order_types(self, async_test_client: TestClient):",
          "def test_order_execution_sides(self, async_test_client: TestClient):",
          "def test_order_execution_exchange_validation(self, async_test_client: TestClient):",
          "def test_order_execution_stop_loss_take_profit(self, async_test_client: TestClient):",
          "def test_order_execution_time_in_force(self, async_test_client: TestClient):",
          "def test_order_execution_batch_orders(self, async_test_client: TestClient):",
          "def test_order_cancellation_endpoint_exists(self, async_test_client: TestClient):",
          "def test_order_status_endpoint_exists(self, async_test_client: TestClient):",
          "def test_order_history_endpoint_exists(self, async_test_client: TestClient):",
          "def test_order_history_query_parameters(self, async_test_client: TestClient):",
          "def test_position_endpoint_exists(self, async_test_client: TestClient):",
          "def test_position_symbol_query(self, async_test_client: TestClient):",
          "def test_risk_check_endpoint_exists(self, async_test_client: TestClient):",
          "def test_risk_limits_endpoint_exists(self, async_test_client: TestClient):",
          "def test_risk_exposure_endpoint_exists(self, async_test_client: TestClient):",
          "def test_portfolio_summary_endpoint_exists(self, async_test_client: TestClient):",
          "def test_strategy_generation_endpoint_exists(self, async_test_client: TestClient):",
          "def test_strategy_generation_endpoint_method_not_allowed(self, async_test_client: TestClient):",
          "def test_strategy_generation_request_structure_validation(self, async_test_client: TestClient):",
          "def test_strategy_generation_required_fields(self, async_test_client: TestClient):",
          "def test_strategy_generation_valid_request_structure(self, async_test_client: TestClient):",
          "def test_strategy_generation_field_validation(self, async_test_client: TestClient, field, value):",
          "def test_strategy_generation_response_format_on_success(self, async_test_client: TestClient):",
          "def test_strategy_generation_error_response_format(self, async_test_client: TestClient):",
          "def test_strategy_generation_concurrent_requests(self, async_test_client: TestClient):",
          "def test_strategy_generation_analysis_types_validation(self, async_test_client: TestClient):",
          "def test_strategy_generation_risk_tolerance_validation(self, async_test_client: TestClient):",
          "def test_strategy_generation_response_time(self, async_test_client: TestClient):",
          "def test_strategy_generation_content_type(self, async_test_client: TestClient):",
          "def test_strategy_generation_multiple_symbols(self, async_test_client: TestClient):",
          "def test_strategy_generation_optional_parameters(self, async_test_client: TestClient):",
          "def test_market_analysis_structure(self, async_test_client: TestClient):",
          "def test_risk_assessment_structure(self, async_test_client: TestClient):",
          "def test_execution_plan_structure(self, async_test_client: TestClient):",
          "def test_strategy_metadata_structure(self, async_test_client: TestClient):",
          "def test_long_analysis_endpoint_exists(self, async_test_client: TestClient):",
          "def test_long_analysis_endpoint_method_not_allowed(self, async_test_client: TestClient):",
          "def test_long_analysis_request_structure_validation(self, async_test_client: TestClient):",
          "def test_long_analysis_required_fields(self, async_test_client: TestClient):",
          "def test_long_analysis_valid_request_structure(self, async_test_client: TestClient):",
          "def test_long_analysis_field_validation(self, async_test_client: TestClient, field, value):",
          "def test_long_analysis_response_format_on_success(self, async_test_client: TestClient):",
          "def test_long_analysis_error_response_format(self, async_test_client: TestClient):",
          "def test_long_analysis_concurrent_requests(self, async_test_client: TestClient):",
          "def test_long_analysis_request_size_limits(self, async_test_client: TestClient):",
          "def test_long_analysis_content_type(self, async_test_client: TestClient):",
          "def test_long_analysis_response_time(self, async_test_client: TestClient):",
          "def test_long_analysis_symbol_formats(self, async_test_client: TestClient):",
          "def test_long_analysis_timeframe_validation(self, async_test_client: TestClient):",
          "def test_long_analysis_endpoint_documentation(self, async_test_client: TestClient):",
          "def test_technical_indicators_structure(self, async_test_client: TestClient):",
          "def test_market_conditions_structure(self, async_test_client: TestClient):",
          "def test_short_analysis_endpoint_exists(self, async_test_client: TestClient):",
          "def test_short_analysis_endpoint_method_not_allowed(self, async_test_client: TestClient):",
          "def test_short_analysis_request_structure_validation(self, async_test_client: TestClient):",
          "def test_short_analysis_required_fields(self, async_test_client: TestClient):",
          "def test_short_analysis_valid_request_structure(self, async_test_client: TestClient):",
          "def test_short_analysis_field_validation(self, async_test_client: TestClient, field, value):",
          "def test_short_analysis_response_format_on_success(self, async_test_client: TestClient):",
          "def test_short_analysis_error_response_format(self, async_test_client: TestClient):",
          "def test_short_analysis_concurrent_requests(self, async_test_client: TestClient):",
          "def test_short_analysis_request_size_limits(self, async_test_client: TestClient):",
          "def test_short_analysis_content_type(self, async_test_client: TestClient):",
          "def test_short_analysis_response_time(self, async_test_client: TestClient):",
          "def test_short_analysis_symbol_formats(self, async_test_client: TestClient):",
          "def test_short_analysis_timeframe_validation(self, async_test_client: TestClient):",
          "def test_short_analysis_endpoint_documentation(self, async_test_client: TestClient):",
          "def test_technical_indicators_structure(self, async_test_client: TestClient):",
          "def test_market_conditions_structure(self, async_test_client: TestClient):",
          "def test_short_strategy_specific_fields(self, async_test_client: TestClient):",
          "def test_risk_management_fields(self, async_test_client: TestClient):",
          "def test_profitability_analysis(self, async_test_client: TestClient):",
          "def test_short_timing_signals(self, async_test_client: TestClient):"
        ],
        "assertions": [
          "assert response.status_code in [200, 422, 400, 401]",
          "assert response.status_code != 404",
          "assert response.status_code == 405",
          "assert response.status_code == 422",
          "assert \"detail\" in error_data",
          "assert response.status_code == 422",
          "assert \"detail\" in error_data",
          "assert response.status_code in [200, 202, 500, 503]",
          "assert response.status_code == 422",
          "assert field in data, f\"Missing required field: {field}\"",
          "assert isinstance(data[\"order_id\"], str)",
          "assert isinstance(data[\"symbol\"], str)",
          "assert isinstance(data[\"side\"], str)",
          "assert isinstance(data[\"amount\"], (int, float))",
          "assert isinstance(data[\"price\"], (int, float))",
          "assert data[\"side\"] in [\"buy\", \"sell\"]",
          "assert data[\"order_type\"] in [\"market\", \"limit\", \"stop\", \"stop_limit\"]",
          "assert data[\"status\"] in [\"pending\", \"filled\", \"cancelled\", \"failed\"]",
          "assert isinstance(response.json()[\"detail\"], str)",
          "assert responses.status_code in valid_status_codes",
          "assert response.status_code in [422, 413, 500]",
          "assert response.status_code in [200, 202, 422, 500, 503]",
          "assert response.status_code == 415",
          "assert response_time < 10.0, f\"Response time too slow: {response_time}s\"",
          "assert response.status_code in [200, 202, 422, 500, 503]",
          "assert response.status_code in [200, 202, 422, 500, 503]",
          "assert response.status_code in [200, 202, 422, 500, 503]",
          "assert response.status_code in [200, 202, 422, 500, 503]",
          "assert response.status_code in [200, 202, 422, 500, 503]",
          "assert response.status_code in [200, 202, 422, 500, 503]",
          "assert response.status_code in [200, 202, 404, 422, 500]",
          "assert response.status_code in [200, 404, 422, 500]",
          "assert response.status_code in [200, 404, 422, 500]",
          "assert response.status_code in [200, 422, 500]",
          "assert response.status_code in [200, 422, 500]",
          "assert response.status_code in [200, 422, 500]",
          "assert response.status_code in [200, 404, 422, 500]",
          "assert response.status_code in [200, 422, 500]",
          "assert response.status_code in [200, 422, 500]",
          "assert response.status_code in [200, 422, 500]",
          "assert response.status_code in [200, 422, 500]",
          "assert response.status_code in [200, 422, 400]",
          "assert response.status_code != 404",
          "assert response.status_code == 405",
          "assert response.status_code == 422",
          "assert \"detail\" in error_data",
          "assert response.status_code == 422",
          "assert \"detail\" in error_data",
          "assert response.status_code in [200, 500, 503]",
          "assert response.status_code == 422",
          "assert field in data, f\"Missing required field: {field}\"",
          "assert isinstance(data[\"strategy_id\"], str)",
          "assert isinstance(data[\"symbol\"], str)",
          "assert isinstance(data[\"final_recommendation\"], str)",
          "assert isinstance(data[\"confidence_score\"], (int, float))",
          "assert data[\"final_recommendation\"] in [\"long\", \"short\", \"hold\"]",
          "assert 0 <= data[\"confidence_score\"] <= 1",
          "assert data[\"strategy_type\"] in [\"aggressive\", \"moderate\", \"conservative\"]",
          "assert isinstance(response.json()[\"detail\"], str)",
          "assert responses.status_code in valid_status_codes",
          "assert response.status_code in [200, 422, 500, 503]",
          "assert response.status_code in [200, 422, 500, 503]",
          "assert response_time < 60.0, f\"Response time too slow: {response_time}s\"",
          "assert response.status_code in [200, 422, 500, 503]",
          "assert response.status_code == 415",
          "assert response.status_code in [200, 422, 500, 503]",
          "assert response.status_code in [200, 422, 500, 503]",
          "assert response.status_code in [200, 422, 500, 503]",
          "#     assert field in analysis, f\"Missing market analysis field: {field}\"",
          "#     assert field in assessment, f\"Missing risk assessment field: {field}\"",
          "#     assert field in plan, f\"Missing execution plan field: {field}\"",
          "assert isinstance(data[field], str)",
          "assert isinstance(data[field], str)  # ISO format datetime",
          "assert isinstance(data[field], str)",
          "assert response.status_code in [200, 422, 400]",
          "assert response.status_code != 404",
          "assert response.status_code == 405",
          "assert response.status_code == 422",
          "assert \"detail\" in error_data",
          "assert response.status_code == 422",
          "assert \"detail\" in error_data",
          "assert response.status_code in [200, 500, 503]",
          "assert response.status_code == 422",
          "assert field in data, f\"Missing required field: {field}\"",
          "assert isinstance(data[\"strategy_id\"], str)",
          "assert isinstance(data[\"symbol\"], str)",
          "assert isinstance(data[\"recommendation\"], str)",
          "assert isinstance(data[\"confidence_score\"], (int, float))",
          "assert data[\"recommendation\"] in [\"buy\", \"hold\", \"sell\"]",
          "assert 0 <= data[\"confidence_score\"] <= 1",
          "assert isinstance(response.json()[\"detail\"], str)",
          "assert responses.status_code in valid_status_codes",
          "assert response.status_code in [422, 413, 500]",
          "assert response.status_code in [200, 422, 500, 503]",
          "assert response.status_code == 415",
          "assert response_time < 30.0, f\"Response time too slow: {response_time}s\"",
          "assert response.status_code in [200, 422, 500, 503]",
          "assert response.status_code in [200, 422, 500, 503]",
          "assert response.status_code == 200",
          "# assert \"long-analysis\" in docs_content.lower() or \"strategy\" in docs_content.lower()",
          "#     assert indicator in indicators, f\"Missing technical indicator: {indicator}\"",
          "#     assert field in conditions, f\"Missing market condition: {field}\"",
          "assert response.status_code in [200, 422, 400]",
          "assert response.status_code != 404",
          "assert response.status_code == 405",
          "assert response.status_code == 422",
          "assert \"detail\" in error_data",
          "assert response.status_code == 422",
          "assert \"detail\" in error_data",
          "assert response.status_code in [200, 500, 503]",
          "assert response.status_code == 422",
          "assert field in data, f\"Missing required field: {field}\"",
          "assert isinstance(data[\"strategy_id\"], str)",
          "assert isinstance(data[\"symbol\"], str)",
          "assert isinstance(data[\"recommendation\"], str)",
          "assert isinstance(data[\"confidence_score\"], (int, float))",
          "assert data[\"recommendation\"] in [\"sell_short\", \"hold\", \"buy\", \"buy_short\"]",
          "assert 0 <= data[\"confidence_score\"] <= 1",
          "assert isinstance(response.json()[\"detail\"], str)",
          "assert responses.status_code in valid_status_codes",
          "assert response.status_code in [422, 413, 500]",
          "assert response.status_code in [200, 422, 500, 503]",
          "assert response.status_code == 415",
          "assert response_time < 30.0, f\"Response time too slow: {response_time}s\"",
          "assert response.status_code in [200, 422, 500, 503]",
          "assert response.status_code in [200, 422, 500, 503]",
          "assert response.status_code == 200",
          "# assert \"short-analysis\" in docs_content.lower() or \"strategy\" in docs_content.lower()",
          "#     assert indicator in indicators, f\"Missing technical indicator: {indicator}\"",
          "#     assert field in conditions, f\"Missing market condition: {field}\"",
          "#         assert isinstance(data[field], (dict, list, str))",
          "#         assert isinstance(data[field], (dict, float, str))",
          "#         assert isinstance(data[field], (dict, float, str))",
          "#     assert isinstance(data[\"timing_signals\"], list)",
          "#         assert isinstance(signal, dict) or isinstance(signal, str)",
          "assert response.status_code == 200",
          "assert \"news\" in data",
          "assert \"total\" in data",
          "assert \"filters\" in data",
          "assert isinstance(data[\"news\"], list)",
          "assert isinstance(data[\"total\"], int)",
          "assert isinstance(data[\"filters\"], dict)",
          "assert field in news_item, f\"Missing required field: {field}\"",
          "assert response.status_code == 200",
          "assert field in data, f\"Missing required field: {field}\"",
          "assert isinstance(data[\"id\"], str)",
          "assert isinstance(data[\"summary_text\"], str)",
          "assert isinstance(data[\"key_points\"], list)",
          "assert isinstance(data[\"market_impact\"], str)",
          "assert isinstance(data[\"news_count\"], int)",
          "assert isinstance(data[\"time_period_hours\"], int)",
          "assert response.status_code == 200",
          "assert field in data, f\"Missing required field: {field}\"",
          "assert isinstance(data[\"task_id\"], str)",
          "assert isinstance(data[\"status\"], str)",
          "assert isinstance(data[\"message\"], str)",
          "assert data[\"status\"] in [\"started\", \"pending\", \"running\", \"completed\", \"failed\"]",
          "assert response.status_code == 200",
          "assert \"filters\" in data",
          "assert data[\"filters\"][\"limit\"] == 10",
          "assert response.status_code == 200",
          "assert \"filters\" in data",
          "assert data[\"filters\"][\"days\"] == 7",
          "assert response.status_code == 200",
          "assert \"filters\" in data",
          "assert data[\"filters\"][\"source\"] == \"CoinDesk\"",
          "assert response.status_code == 200",
          "assert data[\"time_period_hours\"] == 48",
          "assert response.status_code == 200",
          "assert news_item[\"id\"], \"News item missing ID\"",
          "assert news_item[\"title\"], \"News item missing title\"",
          "assert news_item[\"content\"], \"News item missing content\"",
          "assert news_item[\"source\"], \"News item missing source\"",
          "assert isinstance(news_item[\"title\"], str)",
          "assert isinstance(news_item[\"content\"], str)",
          "assert isinstance(news_item[\"source\"], str)",
          "assert isinstance(news_item[\"relevance_score\"], (int, float))",
          "assert 0 <= news_item[\"relevance_score\"] <= 1",
          "assert news_item[\"sentiment\"] in [\"positive\", \"negative\", \"neutral\"]",
          "assert response.status_code in [200, 400, 422]",
          "assert response.status_code in [200, 400, 422]",
          "assert response.status_code == 200",
          "assert \"content-type\" in response.headers",
          "assert \"application/json\" in response.headers[\"content-type\"]"
        ],
        "mock_usage": [],
        "fixtures": [
          "@pytest.mark.parametrize(\"field,value\", [",
          "@pytest.mark.parametrize(\"field,value\", [",
          "@pytest.mark.parametrize(\"field,value\", [",
          "@pytest.mark.parametrize(\"field,value\", [",
          "@pytest.mark.asyncio",
          "@pytest.mark.asyncio",
          "@pytest.mark.asyncio",
          "@pytest.mark.asyncio",
          "@pytest.mark.asyncio",
          "@pytest.mark.asyncio",
          "@pytest.mark.asyncio",
          "@pytest.mark.asyncio"
        ],
        "imports": [
          "import pytest",
          "from fastapi.testclient import TestClient",
          "from httpx import Response",
          "import json",
          "from datetime import datetime, timedelta",
          "import asyncio",
          "import time",
          "import pytest",
          "from fastapi.testclient import TestClient",
          "from httpx import Response",
          "import json",
          "from datetime import datetime, timedelta",
          "import asyncio",
          "import time",
          "import pytest",
          "from fastapi.testclient import TestClient",
          "from httpx import Response",
          "import json",
          "from datetime import datetime, timedelta",
          "import asyncio",
          "import time",
          "import pytest",
          "from fastapi.testclient import TestClient",
          "import json",
          "from datetime import datetime, timedelta",
          "import asyncio",
          "import time",
          "import pytest",
          "import httpx",
          "from datetime import datetime, timedelta",
          "from typing import Dict, Any",
          "from ..conftest import test_client, async_test_client"
        ]
      }
    },
    "integration_tests": {
      "path": "tests/integration",
      "description": "系统集成测试",
      "exists": true,
      "test_files_count": 5,
      "test_files": [
        "test_trading_workflow.py",
        "test_complete_workflow.py",
        "test_long_strategy.py",
        "test_short_strategy.py",
        "test_news_workflow.py"
      ],
      "test_content": {
        "total_lines": 2598,
        "test_methods": [
          "def test_strategy_quality_validation(self, async_test_client: TestClient):",
          "def test_strategy_quality_validation(self, async_test_client: TestClient):",
          "def test_short_strategy_vs_long_strategy_comparison(self, async_test_client: TestClient):",
          "def test_leverage_and_margin_analysis(self, async_test_client: TestClient):",
          "def test_exit_strategy_analysis(self, async_test_client: TestClient):",
          "def test_short_strategy_with_different_timeframes(self, async_test_client: TestClient):"
        ],
        "assertions": [
          "assert risk_check_response.status_code in [200, 422, 500]",
          "assert \"risk_level\" in risk_result",
          "assert \"approved\" in risk_result",
          "assert order_response.status_code in [200, 202, 422, 500]",
          "assert \"order_id\" in order_data",
          "assert order_data[\"symbol\"] == mock_order_request[\"symbol\"]",
          "assert order_data[\"side\"] == mock_order_request[\"side\"]",
          "assert \"status\" in order_status",
          "assert order_status[\"order_id\"] == order_id",
          "assert isinstance(positions, list)",
          "assert cancel_response.status_code in [200, 422, 500]",
          "assert cancel_data[\"order_id\"] == order_id",
          "assert cancel_data[\"status\"] in [\"CANCELED\", \"CANCELLED\"]",
          "assert limits_response.status_code in [200, 422, 500]",
          "assert exposure_response.status_code in [200, 422, 500]",
          "assert risk_check_response.status_code in [200, 422, 500]",
          "assert field in risk_result, f\"Missing risk field: {field}\"",
          "assert positions_response.status_code in [200, 422, 500]",
          "assert symbol_position_response.status_code in [200, 404, 500]",
          "assert portfolio_response.status_code in [200, 422, 500]",
          "assert field in portfolio, f\"Missing portfolio field: {field}\"",
          "assert invalid_response.status_code == 422",
          "assert cancel_response.status_code in [404, 422, 500]",
          "assert status_response.status_code in [404, 422, 500]",
          "assert response.status_code in [200, 202, 422, 500]",
          "assert isinstance(response, Exception)",
          "assert all_orders_response.status_code in [200, 422, 500]",
          "assert btc_orders_response.status_code in [200, 422, 500]",
          "assert filled_orders_response.status_code in [200, 422, 500]",
          "assert time_filtered_response.status_code in [200, 422, 500]",
          "assert paginated_response.status_code in [200, 422, 500]",
          "assert initial_portfolio.status_code in [200, 422, 500]",
          "assert updated_portfolio.status_code in [200, 422, 500]",
          "assert pnl_response.status_code in [200, 404, 422, 500]",
          "assert \"daily_pnl\" in pnl_data or \"total_pnl\" in pnl_data",
          "assert price_response.status_code in [200, 404, 500]",
          "assert depth_response.status_code in [200, 404, 500]",
          "assert stats_response.status_code in [200, 404, 500]",
          "assert exchanges_response.status_code in [200, 404, 500]",
          "assert exchange_info_response.status_code in [200, 404, 500]",
          "assert symbol_info_response.status_code in [200, 404, 500]",
          "assert notification_settings.status_code in [200, 404, 500]",
          "assert notification_history.status_code in [200, 404, 500]",
          "assert update_response.status_code in [200, 404, 422, 500]",
          "assert performance_metrics.status_code in [200, 404, 500]",
          "assert trading_stats.status_code in [200, 404, 500]",
          "assert latency_stats.status_code in [200, 404, 500]",
          "assert response.status_code in [400, 422, 500]",
          "assert order_data[\"status\"] == \"PARTIALLY_FILLED\"",
          "assert order_data[\"filled_amount\"] > 0",
          "assert order_data[\"filled_amount\"] < market_order[\"amount\"]",
          "assert order_data[\"status\"] in [\"EXPIRED\", \"NEW\"]",
          "assert response.status_code in [400, 422, 500]",
          "assert response.status_code in [500, 503, 504]",
          "assert first_response.status_code in [200, 202]",
          "assert second_response.status_code in [200, 202, 409, 422]  # 409 Conflict 或其他错误",
          "assert \"average_price\" in order_data",
          "assert response.status_code in [200, 500, 503]",
          "assert field in data, f\"Missing field: {field}\"",
          "assert data[\"symbol\"] == \"BTC/USDT\"",
          "assert data[\"final_recommendation\"] in [\"long\", \"short\", \"hold\"]",
          "assert 0 <= data[\"confidence_score\"] <= 1",
          "assert data[\"entry_price\"] > 0",
          "assert data[\"position_size_percent\"] > 0",
          "assert len(klines) == 24",
          "assert all(\"open\" in kline for kline in klines)",
          "assert all(\"close\" in kline for kline in klines)",
          "assert len(news) == 1",
          "assert news[0][\"title\"] == \"比特币价格上涨\"",
          "assert news[0][\"sentiment\"] == \"positive\"",
          "assert response.status_code in [200, 404, 422, 500]",
          "assert retrieval_response.status_code in [200, 404, 500]",
          "assert response.status_code in [400, 422, 500]",
          "assert response.status_code in [400, 422, 500]",
          "assert response_time < 30.0, f\"Response time too slow: {response_time}s\"",
          "assert response.status_code in [200, 500, 503]",
          "assert response.status_code in [200, 422, 500, 503]",
          "assert isinstance(response, Exception)",
          "assert data[\"symbol\"] == strategy_request[\"symbol\"]",
          "assert data[\"timeframe\"] == strategy_request[\"timeframe\"]",
          "assert data[\"entry_price\"] <= data[\"take_profit_price\"]",
          "assert data[\"entry_price\"] >= data[\"stop_loss_price\"]",
          "assert data[\"entry_price\"] >= data[\"take_profit_price\"]",
          "assert data[\"entry_price\"] <= data[\"stop_loss_price\"]",
          "assert data[\"position_size_percent\"] <= strategy_request[\"max_position_size\"]",
          "assert \"strategy_id\" in data",
          "assert data[\"symbol\"] == \"BTC/USDT\"",
          "assert data[\"recommendation\"] in [\"buy\", \"hold\", \"sell\"]",
          "assert \"confidence_score\" in data",
          "assert \"entry_price\" in data",
          "assert \"stop_loss_price\" in data",
          "assert \"take_profit_price\" in data",
          "assert \"technical_indicators\" in data",
          "assert \"market_conditions\" in data",
          "assert \"risk_factors\" in data",
          "assert len(klines) == 168",
          "assert all(kline[\"symbol\"] == \"BTC/USDT\" for kline in klines)",
          "assert all(\"close\" in kline for kline in klines)",
          "assert \"rsi\" in result",
          "assert \"macd\" in result",
          "assert \"moving_averages\" in result",
          "assert 0 <= result[\"rsi\"] <= 100",
          "assert result[\"recommendation\"] in [\"buy\", \"hold\", \"sell\"]",
          "assert 0 <= result[\"confidence\"] <= 1",
          "assert \"entry_price\" in result",
          "assert \"stop_loss\" in result",
          "assert \"take_profit\" in result",
          "assert response.status_code in [500, 503]",
          "assert \"detail\" in error_data",
          "assert response.status_code in [200, 429, 500, 503]",
          "mock_cache.get.assert_called()",
          "mock_cache.set.assert_called()",
          "assert response_time < 300.0, f\"Response time {response_time}s exceeds performance requirement\"",
          "mock_db_session.add.assert_called()",
          "mock_db_session.commit.assert_called()",
          "assert \"confidence_score\" in data",
          "assert \"risk_factors\" in data",
          "assert \"reasoning\" in data",
          "assert data[\"recommendation\"] in [\"hold\", \"sell\"]",
          "#     assert field in conditions",
          "assert \"strategy_id\" in data",
          "assert data[\"symbol\"] == \"BTC/USDT\"",
          "assert data[\"recommendation\"] in [\"sell_short\", \"hold\", \"buy\"]",
          "assert \"confidence_score\" in data",
          "assert \"entry_price\" in data",
          "assert \"stop_loss_price\" in data",
          "assert \"take_profit_price\" in data",
          "assert \"technical_indicators\" in data",
          "assert \"market_conditions\" in data",
          "assert \"risk_factors\" in data",
          "assert len(klines) == 168",
          "assert all(kline[\"symbol\"] == \"BTC/USDT\" for kline in klines)",
          "assert all(\"close\" in kline for kline in klines)",
          "assert \"market_analysis\" in result",
          "assert result[\"market_analysis\"][\"trend_direction\"] in [\"downtrend\", \"sideways\", \"uptrend\"]",
          "assert result.recommendation in [\"sell_short\", \"hold\", \"buy\"]",
          "assert 0 <= result.confidence_score <= 1",
          "assert result.entry_price > 0",
          "assert result.stop_loss_price > 0",
          "assert result.take_profit_price > 0",
          "assert response.status_code in [500, 503]",
          "assert \"detail\" in error_data",
          "assert response.status_code in [200, 429, 500, 503]",
          "mock_cache.get.assert_called()",
          "mock_cache.set.assert_called()",
          "mock_db_session.add.assert_called()",
          "mock_db_session.commit.assert_called()",
          "assert \"confidence_score\" in data",
          "assert \"risk_factors\" in data",
          "assert \"reasoning\" in data",
          "assert data[\"recommendation\"] in [\"hold\", \"buy\"]",
          "#     assert field in conditions",
          "assert long_status in [200, 500, 503]",
          "assert short_status in [200, 500, 503]",
          "#     assert isinstance(short_data[\"strategy_comparison\"], dict)",
          "#         assert isinstance(data[field], (dict, float, str))",
          "#     assert \"exit_strategy\" in execution",
          "assert response_time < 300.0, f\"Response time {response_time}s exceeds performance requirement\"",
          "assert len(results) == len(timeframes)",
          "assert timeframe in [\"15m\", \"1h\", \"4h\", \"1d\"]",
          "assert recommendation in [\"sell_short\", \"hold\", \"buy\", \"sell\"]",
          "assert 0 <= confidence <= 1.0",
          "assert collect_response.status_code == 200",
          "assert \"task_id\" in task_data",
          "assert task_data[\"status\"] in [\"started\", \"pending\"]",
          "assert news_response.status_code == 200",
          "assert \"news\" in news_data",
          "assert isinstance(news_data[\"news\"], list)",
          "assert len(news_data[\"news\"]) > 0",
          "assert summary_response.status_code == 200",
          "assert \"summary_text\" in summary_data",
          "assert \"key_points\" in summary_data",
          "assert \"market_impact\" in summary_data",
          "assert response.status_code == 200",
          "assert len(news_list) <= 50  # 限制数量",
          "assert all(news[\"relevance_score\"] >= 0.7 for news in news_list)",
          "assert all(news[\"published_at\"] >= \"2025-09-23\" for news in news_list)  # 15天内",
          "assert response.status_code == 200",
          "assert \"summary_text\" in summary_data",
          "assert \"key_points\" in summary_data",
          "assert \"market_impact\" in summary_data",
          "assert len(summary_data[\"key_points\"]) > 0",
          "assert summary_data[\"market_impact\"] in [\"high\", \"medium\", \"low\"]",
          "assert len(summary_data[\"summary_text\"]) > 10  # 有实际内容",
          "assert any(keyword in summary_data[\"summary_text\"].lower()",
          "assert collect_response.status_code == 200",
          "assert news_response.status_code == 200",
          "assert summary_response.status_code == 200",
          "assert len(news_response.json()[\"news\"]) >= 0",
          "assert \"summary_text\" in summary_response.json()",
          "assert response1.status_code == 200",
          "mock_cache.get.assert_called()",
          "mock_cache.set.assert_called()  # 数据应该被缓存",
          "assert response2.status_code == 200",
          "assert response2.json()[\"total\"] == len(mock_news_data)",
          "assert collect_response.status_code in [200, 500, 503]",
          "assert news_response.status_code in [200, 500]  # 可能返回缓存数据或错误",
          "assert processing_time < 5.0  # 5秒内完成",
          "assert all(response.status_code == 200 for response in [collect_response, news_response, summary_response])",
          "assert len(news_data[\"news\"]) <= 50"
        ],
        "mock_usage": [
          "from unittest.mock import AsyncMock, MagicMock, patch",
          "with patch('backend.src.services.exchange_data_collector.ExchangeDataCollector') as MockExchange:",
          "mock_exchange = AsyncMock()",
          "MockExchange.return_value = mock_exchange",
          "with patch('backend.src.services.exchange_data_collector.ExchangeDataCollector') as MockExchange:",
          "mock_exchange = AsyncMock()",
          "MockExchange.return_value = mock_exchange",
          "with patch('backend.src.services.exchange_data_collector.ExchangeDataCollector') as MockExchangeCancel:",
          "mock_exchange_cancel = AsyncMock()",
          "MockExchangeCancel.return_value = mock_exchange_cancel",
          "with patch('backend.src.services.exchange_data_collector.ExchangeDataCollector') as MockExchange:",
          "mock_exchange = AsyncMock()",
          "MockExchange.return_value = mock_exchange",
          "with patch('backend.src.services.position_monitor.PositionMonitor') as MockMonitor:",
          "mock_monitor = AsyncMock()",
          "MockMonitor.return_value = mock_monitor",
          "with patch('backend.src.services.exchange_data_collector.ExchangeDataCollector') as MockExchange:",
          "mock_exchange = AsyncMock()",
          "MockExchange.return_value = mock_exchange",
          "with patch('backend.src.services.exchange_data_collector.ExchangeDataCollector') as MockExchange:",
          "mock_exchange = AsyncMock()",
          "MockExchange.return_value = mock_exchange",
          "with patch('backend.src.services.exchange_data_collector.ExchangeDataCollector') as MockExchange:",
          "mock_exchange = AsyncMock()",
          "MockExchange.return_value = mock_exchange",
          "with patch('backend.src.services.exchange_data_collector.ExchangeDataCollector') as MockExchange:",
          "mock_exchange = AsyncMock()",
          "MockExchange.return_value = mock_exchange",
          "with patch('backend.src.services.exchange_data_collector.ExchangeDataCollector') as MockExchange:",
          "mock_exchange = AsyncMock()",
          "MockExchange.return_value = mock_exchange",
          "with patch('backend.src.services.exchange_data_collector.ExchangeDataCollector') as MockExchange:",
          "mock_exchange = AsyncMock()",
          "MockExchange.return_value = mock_exchange",
          "with patch('backend.src.services.exchange_data_collector.ExchangeDataCollector') as MockExchange:",
          "mock_exchange = AsyncMock()",
          "MockExchange.return_value = mock_exchange",
          "with patch('backend.src.services.exchange_data_collector.ExchangeDataCollector') as MockExchange:",
          "mock_exchange = AsyncMock()",
          "MockExchange.return_value = mock_exchange",
          "from unittest.mock import AsyncMock, MagicMock, patch",
          "mock_news_collector = AsyncMock(spec=NewsCollector)",
          "mock_news_summarizer = AsyncMock(spec=LLMNewsSummarizer)",
          "mock_exchange_collector = AsyncMock(spec=ExchangeDataCollector)",
          "mock_technical_engine = AsyncMock(spec=TechnicalAnalysisEngine)",
          "mock_long_analyzer = AsyncMock(spec=LLMLongStrategyAnalyzer)",
          "mock_short_analyzer = AsyncMock(spec=LLMShortStrategyAnalyzer)",
          "mock_aggregator = AsyncMock(spec=StrategyAggregator)",
          "mock_strategy_generator = AsyncMock(spec=LLMStrategyGenerator)",
          "with patch('backend.src.services.news_collector.NewsCollector') as MockNewsCollector:",
          "MockNewsCollector.return_value = mock_news_collector",
          "with patch('backend.src.services.llm_news_summarizer.LLMNewsSummarizer') as MockNewsSummarizer:",
          "MockNewsSummarizer.return_value = mock_news_summarizer",
          "with patch('backend.src.services.exchange_data_collector.ExchangeDataCollector') as MockExchangeCollector:",
          "MockExchangeCollector.return_value = mock_exchange_collector",
          "with patch('backend.src.services.technical_analysis_engine.TechnicalAnalysisEngine') as MockTechnicalEngine:",
          "MockTechnicalEngine.return_value = mock_technical_engine",
          "with patch('backend.src.services.llm_long_strategy_analyzer.LLMLongStrategyAnalyzer') as MockLongAnalyzer:",
          "MockLongAnalyzer.return_value = mock_long_analyzer",
          "with patch('backend.src.services.llm_short_strategy_analyzer.LLMShortStrategyAnalyzer') as MockShortAnalyzer:",
          "MockShortAnalyzer.return_value = mock_short_analyzer",
          "with patch('backend.src.services.strategy_aggregator.StrategyAggregator') as MockAggregator:",
          "MockAggregator.return_value = mock_aggregator",
          "with patch('backend.src.services.llm_strategy_generator.LLMStrategyGenerator') as MockGenerator:",
          "MockGenerator.return_value = mock_strategy_generator",
          "with patch('backend.src.services.exchange_data_collector.ExchangeDataCollector') as MockCollector:",
          "mock_collector = AsyncMock()",
          "MockCollector.return_value = mock_collector",
          "with patch('backend.src.services.news_collector.NewsCollector') as MockCollector:",
          "mock_collector = AsyncMock()",
          "MockCollector.return_value = mock_collector",
          "with patch('backend.src.services.llm_strategy_generator.LLMStrategyGenerator') as MockGenerator:",
          "mock_generator = AsyncMock()",
          "MockGenerator.return_value = mock_generator",
          "from unittest.mock import AsyncMock, MagicMock, patch",
          "with patch('backend.src.services.exchange_data_collector.ExchangeDataCollector') as MockCollector:",
          "mock_collector = AsyncMock()",
          "MockCollector.return_value = mock_collector",
          "with patch('backend.src.services.technical_analysis_engine.TechnicalAnalysisEngine') as MockEngine:",
          "mock_engine = AsyncMock()",
          "MockEngine.return_value = mock_engine",
          "with patch('backend.src.services.llm_long_strategy_analyzer.LLMLongStrategyAnalyzer') as MockAnalyzer:",
          "mock_analyzer = AsyncMock()",
          "MockAnalyzer.return_value = mock_analyzer",
          "with patch('backend.src.services.exchange_data_collector.ExchangeDataCollector') as MockCollector:",
          "mock_collector = AsyncMock()",
          "MockCollector.return_value = mock_collector",
          "with patch('backend.src.services.technical_analysis_engine.TechnicalAnalysisEngine') as MockEngine:",
          "mock_engine = AsyncMock()",
          "MockEngine.return_value = mock_engine",
          "with patch('backend.src.services.llm_long_strategy_analyzer.LLMLongStrategyAnalyzer') as MockAnalyzer:",
          "mock_analyzer = AsyncMock()",
          "MockAnalyzer.return_value = mock_analyzer",
          "with patch('backend.src.services.exchange_data_collector.ExchangeDataCollector') as MockCollector:",
          "mock_collector = AsyncMock()",
          "MockCollector.return_value = mock_collector",
          "with patch('backend.src.services.exchange_data_collector.ExchangeDataCollector') as MockCollector, \\",
          "patch('backend.src.services.technical_analysis_engine.TechnicalAnalysisEngine') as MockEngine, \\",
          "patch('backend.src.services.llm_long_strategy_analyzer.LLMLongStrategyAnalyzer') as MockAnalyzer:",
          "mock_collector = AsyncMock()",
          "MockCollector.return_value = mock_collector",
          "mock_engine = AsyncMock()",
          "MockEngine.return_value = mock_engine",
          "mock_analyzer = AsyncMock()",
          "MockAnalyzer.return_value = mock_analyzer",
          "with patch('backend.src.services.exchange_data_collector.ExchangeDataCollector') as MockCollector, \\",
          "patch('backend.src.cache.get_cache') as MockCache:",
          "mock_cache = MagicMock()",
          "MockCache.return_value = mock_cache",
          "mock_collector = AsyncMock()",
          "MockCollector.return_value = mock_collector",
          "with patch('backend.src.services.exchange_data_collector.ExchangeDataCollector') as MockCollector, \\",
          "patch('backend.src.services.technical_analysis_engine.TechnicalAnalysisEngine') as MockEngine, \\",
          "patch('backend.src.services.llm_long_strategy_analyzer.LLMLongStrategyAnalyzer') as MockAnalyzer:",
          "mock_collector = AsyncMock()",
          "MockCollector.return_value = mock_collector",
          "mock_engine = AsyncMock()",
          "MockEngine.return_value = mock_engine",
          "mock_analyzer = AsyncMock()",
          "MockAnalyzer.return_value = mock_analyzer",
          "with patch('backend.src.services.exchange_data_collector.ExchangeDataCollector') as MockCollector, \\",
          "patch('backend.src.models.technical_analysis.TechnicalAnalysis') as MockModel, \\",
          "patch('backend.src.core.database.SessionLocal') as MockSession:",
          "mock_collector = AsyncMock()",
          "MockCollector.return_value = mock_collector",
          "mock_db_session = MagicMock()",
          "MockSession.return_value = mock_db_session",
          "mock_model = MagicMock()",
          "MockModel.return_value = mock_model",
          "from unittest.mock import AsyncMock, MagicMock, patch",
          "with patch('backend.src.services.exchange_data_collector.ExchangeDataCollector') as MockCollector:",
          "mock_collector = AsyncMock()",
          "MockCollector.return_value = mock_collector",
          "with patch('backend.src.services.technical_analysis_engine.TechnicalAnalysisEngine') as MockEngine:",
          "mock_engine = AsyncMock()",
          "MockEngine.return_value = mock_engine",
          "with patch('backend.src.services.llm_short_strategy_analyzer.LLMShortStrategyAnalyzer') as MockAnalyzer:",
          "mock_analyzer = AsyncMock()",
          "MockAnalyzer.return_value = mock_analyzer",
          "with patch('backend.src.services.exchange_data_collector.ExchangeDataCollector') as MockCollector:",
          "mock_collector = AsyncMock()",
          "MockCollector.return_value = mock_collector",
          "with patch('backend.src.services.technical_analysis_engine.TechnicalAnalysisEngine') as MockEngine:",
          "mock_engine = AsyncMock()",
          "MockEngine.return_value = mock_engine",
          "with patch('backend.src.services.llm_short_strategy_analyzer.LLMShortStrategyAnalyzer') as MockAnalyzer:",
          "mock_analyzer = AsyncMock()",
          "MockAnalyzer.return_value = mock_analyzer",
          "with patch('backend.src.services.exchange_data_collector.ExchangeDataCollector') as MockCollector:",
          "mock_collector = AsyncMock()",
          "MockCollector.return_value = mock_collector",
          "with patch('backend.src.services.exchange_data_collector.ExchangeDataCollector') as MockCollector, \\",
          "patch('backend.src.services.technical_analysis_engine.TechnicalAnalysisEngine') as MockEngine, \\",
          "patch('backend.src.services.llm_short_strategy_analyzer.LLMShortStrategyAnalyzer') as MockAnalyzer:",
          "mock_collector = AsyncMock()",
          "MockCollector.return_value = mock_collector",
          "mock_engine = AsyncMock()",
          "MockEngine.return_value = mock_engine",
          "mock_analyzer = AsyncMock()",
          "MockAnalyzer.return_value = mock_analyzer",
          "with patch('backend.src.services.exchange_data_collector.ExchangeDataCollector') as MockCollector, \\",
          "patch('backend.src.core.cache.get_cache') as MockCache:",
          "mock_cache = MagicMock()",
          "MockCache.return_value = mock_cache",
          "mock_collector = AsyncMock()",
          "MockCollector.return_value = mock_collector",
          "with patch('backend.src.services.exchange_data_collector.ExchangeDataCollector') as MockCollector, \\",
          "patch('backend.src.models.technical_analysis.TechnicalAnalysis') as MockModel, \\",
          "patch('backend.src.core.database.SessionLocal') as MockSession:",
          "mock_collector = AsyncMock()",
          "MockCollector.return_value = mock_collector",
          "mock_db_session = MagicMock()",
          "MockSession.return_value = mock_db_session",
          "mock_model = MagicMock()",
          "MockModel.return_value = mock_model",
          "with patch('backend.src.services.exchange_data_collector.ExchangeDataCollector') as MockCollector, \\",
          "patch('backend.src.services.technical_analysis_engine.TechnicalAnalysisEngine') as MockEngine, \\",
          "patch('backend.src.services.llm_short_strategy_analyzer.LLMShortStrategyAnalyzer') as MockAnalyzer:",
          "mock_collector = AsyncMock()",
          "MockCollector.return_value = mock_collector",
          "mock_engine = AsyncMock()",
          "MockEngine.return_value = mock_engine",
          "mock_analyzer = AsyncMock()",
          "MockAnalyzer.return_value = mock_analyzer",
          "from unittest.mock import Mock, AsyncMock, patch",
          "with patch('src.services.llm_news_summarizer.LLMNewsSummarizer') as mock_summarizer:",
          "mock_summarizer.return_value = Mock()",
          "with patch('src.services.news_collector.NewsCollector') as mock_collector:",
          "with patch('src.services.llm_news_summarizer.LLMNewsSummarizer') as mock_summarizer:",
          "mock_summarizer.return_value = Mock()",
          "with patch('src.services.news_collector.NewsCollector') as mock_collector:",
          "with patch('src.models.news.NewsData') as mock_news_model:",
          "mock_instance = Mock()",
          "with patch('src.models.news.NewsSummary') as mock_summary_model:",
          "mock_summary_instance = Mock()",
          "with patch('src.core.cache.get_cache') as mock_cache:",
          "with patch('src.services.news_collector.NewsCollector') as mock_collector:",
          "with patch('src.services.news_collector.NewsCollector') as mock_collector:",
          "with patch('src.services.news_collector.NewsCollector') as mock_collector:"
        ],
        "fixtures": [
          "@pytest.fixture",
          "@pytest.fixture",
          "@pytest.fixture",
          "@pytest.fixture",
          "@pytest.fixture",
          "@pytest.fixture",
          "@pytest.fixture",
          "@pytest.fixture",
          "@pytest.fixture",
          "@pytest.fixture",
          "@pytest.fixture",
          "@pytest.fixture",
          "@pytest.fixture",
          "@pytest.mark.integration",
          "@pytest.mark.asyncio",
          "@pytest.mark.integration",
          "@pytest.mark.asyncio",
          "@pytest.mark.integration",
          "@pytest.mark.asyncio",
          "@pytest.mark.integration",
          "@pytest.mark.asyncio",
          "@pytest.mark.integration",
          "@pytest.mark.asyncio",
          "@pytest.mark.integration",
          "@pytest.mark.asyncio",
          "@pytest.mark.integration",
          "@pytest.mark.asyncio"
        ],
        "imports": [
          "import pytest",
          "import asyncio",
          "from datetime import datetime, timedelta",
          "import json",
          "from decimal import Decimal",
          "from fastapi.testclient import TestClient",
          "from backend.src.models.trading_order import TradingOrder, OrderStatus, OrderType, OrderSide",
          "from backend.src.models.position import Position, PositionSide",
          "from backend.src.services.order_manager import OrderManager",
          "from backend.src.services.risk_manager import RiskManager",
          "from backend.src.services.trading_executor import TradingExecutor",
          "from backend.src.services.position_monitor import PositionMonitor",
          "import pytest",
          "import asyncio",
          "from datetime import datetime, timedelta",
          "import json",
          "from fastapi.testclient import TestClient",
          "from backend.src.models.news import NewsData, NewsSummary",
          "from backend.src.models.technical_analysis import TechnicalAnalysis",
          "from backend.src.services.news_collector import NewsCollector",
          "from backend.src.services.llm_news_summarizer import LLMNewsSummarizer",
          "from backend.src.services.exchange_data_collector import ExchangeDataCollector",
          "from backend.src.services.technical_analysis_engine import TechnicalAnalysisEngine",
          "from backend.src.services.llm_long_strategy_analyzer import LLMLongStrategyAnalyzer",
          "from backend.src.services.llm_short_strategy_analyzer import LLMShortStrategyAnalyzer",
          "from backend.src.services.strategy_aggregator import StrategyAggregator",
          "from backend.src.services.llm_strategy_generator import LLMStrategyGenerator",
          "import time",
          "import pytest",
          "import asyncio",
          "from datetime import datetime, timedelta",
          "from fastapi.testclient import TestClient",
          "import json",
          "from backend.src.services.exchange_data_collector import ExchangeDataCollector",
          "from backend.src.services.technical_analysis_engine import TechnicalAnalysisEngine",
          "from backend.src.services.llm_long_strategy_analyzer import LLMLongStrategyAnalyzer",
          "import time",
          "import pytest",
          "import asyncio",
          "from datetime import datetime, timedelta",
          "from fastapi.testclient import TestClient",
          "import json",
          "from backend.src.services.exchange_data_collector import ExchangeDataCollector",
          "from backend.src.services.technical_analysis_engine import TechnicalAnalysisEngine",
          "from backend.src.services.llm_short_strategy_analyzer import LLMShortStrategyAnalyzer",
          "import time",
          "import pytest",
          "import asyncio",
          "from datetime import datetime, timedelta",
          "from typing import List, Dict, Any",
          "from ..conftest import async_test_client, mock_news_data, mock_llm_service",
          "import time"
        ]
      }
    },
    "unit_tests": {
      "path": "tests/unit",
      "description": "单元测试",
      "exists": true,
      "test_files_count": 4,
      "test_files": [
        "test_risk_management.py",
        "test_technical_analysis.py",
        "test_dynamic_fund_manager.py",
        "test_news_filter.py"
      ],
      "test_content": {
        "total_lines": 2187,
        "test_methods": [
          "def test_calculate_position_risk(self, risk_manager, mock_positions):",
          "def test_calculate_order_risk_buy(self, risk_manager, mock_order_request):",
          "def test_calculate_order_risk_sell(self, risk_manager, mock_order_request):",
          "def test_calculate_portfolio_risk(self, risk_manager, mock_positions):",
          "def test_check_concentration_risk(self, risk_manager):",
          "def test_check_leverage_risk(self, risk_manager):",
          "def test_assess_market_risk(self, risk_manager):",
          "def test_validate_order_parameters(self, risk_manager, mock_order_request):",
          "def test_check_position_size_limits(self, risk_manager):",
          "def test_calculate_stop_loss_distance(self, risk_manager):",
          "def test_assess_risk_reward_ratio(self, risk_manager):",
          "def test_check_time_risk(self, risk_manager):",
          "def test_assess_correlation_risk(self, risk_manager):",
          "def test_generate_risk_report(self, risk_manager, mock_positions, mock_order_request):",
          "def test_update_risk_limits(self, risk_manager):",
          "def test_monitor_risk_alerts(self, risk_manager):",
          "def test_stress_test_risk_calculations(self, risk_manager):",
          "def test_edge_cases(self, risk_manager):",
          "def test_risk_assessment_creation(self):",
          "def test_risk_assessment_comparison(self):",
          "def test_risk_assessment_aggregation(self):",
          "def test_risk_threshold_validation(self):",
          "def test_price_deviation_calculation(self):",
          "def test_volatility_calculation(self):",
          "def test_leverage_margin_calculation(self):",
          "def test_drawdown_calculation(self):",
          "def test_rsi_calculation_basic(self, sample_price_data):",
          "def test_rsi_extreme_values(self):",
          "def test_rsi_period_validation(self):",
          "def test_rsi_insufficient_data(self):",
          "def test_macd_calculation_basic(self, sample_ohlc_data):",
          "def test_macd_crossover_detection(self, sample_ohlc_data):",
          "def test_macd_divergence_detection(self, sample_ohlc_data):",
          "def test_bollinger_bands_calculation(self, volatile_price_data):",
          "def test_bollinger_band_squeeze_detection(self, volatile_price_data):",
          "def test_bollinger_band_breakout_signals(self, volatile_price_data):",
          "def test_sma_calculation(self, trend_price_data):",
          "def test_ema_calculation(self, trend_price_data):",
          "def test_ma_crossover_signals(self, trend_price_data):",
          "def test_ma_trend_analysis(self, trend_price_data):",
          "def test_volume_profile(self, volume_price_data):",
          "def test_on_balance_volume(self, volume_price_data):",
          "def test_volume_moving_average(self, volume_price_data):",
          "def test_support_level_identification(self, swing_price_data):",
          "def test_resistance_level_identification(self, swing_price_data):",
          "def test_pivot_point_calculation(self, swing_price_data):",
          "def test_head_shoulders_pattern(self, pattern_data):",
          "def test_double_top_bottom_patterns(self, pattern_data):",
          "def test_triangle_patterns(self, pattern_data):",
          "def test_comprehensive_analysis(self):",
          "def test_analysis_performance(self):",
          "def test_analysis_accuracy(self):",
          "def test_edge_cases(self):",
          "def test_initial_allocation_setup(self, fund_manager):",
          "def test_calculate_current_performance(self, fund_manager, mock_positions):",
          "def test_rebalance_allocation(self, fund_manager, mock_positions):",
          "def test_performance_based_adjustment(self, fund_manager):",
          "def test_risk_based_adjustment(self, fund_manager, mock_positions):",
          "def test_volatility_based_adjustment(self, fund_manager):",
          "def test_correlation_based_adjustment(self, fund_manager):",
          "def test_liquidity_based_adjustment(self, fund_manager):",
          "def test_market_cycle_adjustment(self, fund_manager):",
          "def test_combined_adjustment_strategy(self, fund_manager, mock_positions):",
          "def test_allocation_change_validation(self, fund_manager):",
          "def test_minimum_allocation_enforcement(self, fund_manager):",
          "def test_maximum_allocation_enforcement(self, fund_manager):",
          "def test_allocation_history_tracking(self, fund_manager):",
          "def test_performance_tracking(self, fund_manager, mock_positions):",
          "def test_rebalancing_triggers(self, fund_manager, mock_positions):",
          "def test_automated_rebalancing(self, fund_manager, mock_positions):",
          "def test_fund_allocation_strategies(self, fund_manager):",
          "def test_emergency_adjustments(self, fund_manager):",
          "def test_allocation_optimization(self, fund_manager, mock_positions):",
          "def test_backtesting_allocation_strategy(self, fund_manager):",
          "def test_fund_allocation_creation(self):",
          "def test_fund_allocation_comparison(self):",
          "def test_fund_allocation_calculation(self):",
          "def test_performance_metrics_creation(self):",
          "def test_sharpe_ratio_calculation(self):",
          "def test_max_drawdown_calculation(self):",
          "def test_calmaratio_calculation(self):",
          "def test_information_ratio_calculation(self):",
          "def test_empty_positions(self, fund_manager):",
          "def test_zero_funds(self):",
          "def test_single_strategy_allocation(self, fund_manager):",
          "def test_extreme_performance_scenarios(self, fund_manager):",
          "def test_rapid_rebalancing(self, fund_manager):",
          "def test_invalid_allocation_data(self, fund_manager):",
          "def test_news_relevance_filtering(self):",
          "def test_news_time_filtering(self):",
          "def test_news_quality_scoring(self):",
          "def test_news_deduplication(self):",
          "def test_news_sentiment_analysis(self):",
          "def test_news_sorting_by_relevance(self):",
          "def test_news_source_categorization(self):",
          "def test_news_limit_enforcement(self):",
          "def test_relevance_threshold_filtering(self, relevance_score, expected_filter):",
          "def test_news_aggregation_by_source(self):"
        ],
        "assertions": [
          "assert risk_result[\"symbol\"] == position[\"symbol\"]",
          "assert risk_result[\"side\"] == position_side",
          "assert risk_result[\"risk_amount\"] == risk_amount",
          "assert risk_result[\"risk_percentage\"] == risk_percentage",
          "assert risk_result[\"risk_level\"] == expected_risk_level",
          "assert risk_assessment[\"symbol\"] == mock_order_request[\"symbol\"]",
          "assert risk_assessment[\"side\"] == mock_order_request[\"side\"]",
          "assert risk_assessment[\"amount\"] == mock_order_request[\"amount\"]",
          "assert risk_assessment[\"price\"] == mock_order_request[\"price\"]",
          "assert risk_assessment[\"order_value\"] == order_value",
          "assert risk_assessment[\"portfolio_percentage\"] == portfolio_percentage",
          "assert risk_assessment[\"risk_level\"] == expected_risk_level",
          "assert risk_assessment[\"side\"] == \"sell\"",
          "assert risk_assessment[\"portfolio_percentage\"] == portfolio_percentage",
          "assert \"total_value\" in portfolio_risk",
          "assert \"total_unrealized_pnl\" in portfolio_risk",
          "assert \"risk_summary\" in portfolio_risk",
          "assert portfolio_risk[\"total_value\"] == expected_total_value",
          "assert portfolio_risk[\"total_unrealized_pnl\"] == expected_total_pnl",
          "assert high_risk_count == expected_high_risk",
          "assert symbol in concentration_risk",
          "assert concentration_risk[symbol][\"percentage\"] == concentration",
          "assert concentration_risk[\"BTC/USDT\"][\"risk_level\"] == expected_risk",
          "assert leverage_risk[\"symbol\"] == position[\"symbol\"]",
          "assert leverage_risk[\"leverage\"] == position[\"leverage\"]",
          "assert \"margin_ratio\" in leverage_risk",
          "assert leverage_risk[\"margin_ratio\"] == expected_margin_ratio",
          "assert leverage_risk[\"risk_level\"] == expected_risk",
          "assert \"risk_level\" in market_risk",
          "assert \"risk_factors\" in market_risk",
          "assert \"recommendation\" in market_risk",
          "assert market_risk[\"risk_level\"] == RiskLevel.HIGH",
          "assert \"high_volatility\" in [f[\"type\"] for f in market_risk[\"risk_factors\"]]",
          "assert \"overbought\" in [f[\"type\"] for f in market_risk[\"risk_factors\"]]",
          "assert validation_result[\"valid\"]",
          "assert validation_result[\"errors\"] == []",
          "assert not invalid_validation[\"valid\"]",
          "assert len(invalid_validation[\"errors\"]) > 0",
          "assert \"approved\" in limit_check",
          "assert \"max_allowed_amount\" in limit_check",
          "assert \"current_amount\" in limit_check",
          "assert not large_check[\"approved\"]",
          "assert \"reason\" in large_check",
          "assert stop_loss_distance[\"percentage\"] == expected_distance",
          "assert stop_loss_distance[\"is_reasonable\"] == (5 <= expected_distance <= 15)",
          "assert short_stop_loss[\"percentage\"] == short_distance",
          "assert risk_reward[\"ratio\"] == expected_ratio",
          "assert risk_reward[\"is_acceptable\"] == (expected_ratio >= 2.0)",
          "assert not poor_ratio[\"is_acceptable\"]",
          "assert \"time_remaining\" in time_risk",
          "assert \"risk_level\" in time_risk",
          "assert urgent_risk[\"risk_level\"] == RiskLevel.HIGH",
          "assert urgent_risk[\"is_expiring_soon\"]",
          "assert \"average_correlation\" in correlation_risk",
          "assert \"risk_level\" in correlation_risk",
          "assert \"high_correlation_pairs\" in correlation_risk",
          "assert (\"BTC/USDT\", \"ETH/USDT\") in correlation_risk[\"high_correlation_pairs\"]",
          "assert \"timestamp\" in risk_report",
          "assert \"overall_risk_level\" in risk_report",
          "assert \"portfolio_risk\" in risk_report",
          "assert \"order_risk\" in risk_report",
          "assert \"recommendations\" in risk_report",
          "assert \"risk_factors\" in risk_report",
          "assert len(risk_report[\"recommendations\"]) > 0",
          "assert len(risk_report[\"risk_factors\"]) > 0",
          "assert updated_limits[\"max_position_size_percent\"] == 25.0",
          "assert updated_limits[\"max_portfolio_risk_percent\"] == 15.0",
          "assert updated_limits[\"max_leverage\"] == 10.0",
          "assert len(alerts) > 0",
          "assert \"portfolio_risk\" in alert_types",
          "assert \"position_risk\" in alert_types",
          "assert len(severe_alerts) > 0",
          "assert monitoring_count == 5",
          "assert calculation_time < 1.0",
          "assert portfolio_risk[\"total_value\"] > 0",
          "assert len(portfolio_risk[\"position_risks\"]) == 100",
          "assert empty_risk[\"total_value\"] == 0",
          "assert empty_risk[\"total_unrealized_pnl\"] == 0",
          "assert zero_risk[\"risk_amount\"] == 0",
          "assert tiny_risk[\"portfolio_percentage\"] < 0.001",
          "assert assessment.risk_level == RiskLevel.HIGH",
          "assert assessment.risk_score == 0.85",
          "assert \"high_volatility\" in assessment.risk_factors",
          "assert len(assessment.recommendations) == 2",
          "assert high_risk.is_higher_risk_than(low_risk)",
          "assert not low_risk.is_higher_risk_than(high_risk)",
          "assert abs(aggregated.risk_score - expected_score) < 0.01",
          "assert aggregated.risk_level == RiskLevel.HIGH",
          "assert assessment.exceeds_threshold(0.8)",
          "assert not assessment.exceeds_threshold(0.95)",
          "assert assessment.is_at_or_above_level(RiskLevel.MEDIUM)",
          "assert assessment.is_at_or_above_level(RiskLevel.HIGH)",
          "assert not assessment.is_at_or_above_level(RiskLevel.CRITICAL)",
          "assert abs(deviation - 11.11) < 0.01",
          "assert avg_price == Decimal(\"50300.0\")",
          "assert std_dev > 0",
          "assert required_margin == Decimal(\"5000.0\")",
          "assert margin_ratio == 10.0",
          "assert abs(drawdown - 15.0) < 0.01",
          "assert recovery == -drawdown",
          "assert 0 <= result <= 100",
          "assert isinstance(result, (int, float))",
          "assert len(rising_prices) == 20",
          "assert len(falling_prices) == 20",
          "assert len(klines) == 20",
          "assert len(insufficient_data) < 14",
          "# assert \"macd_line\" in macd_result",
          "# assert \"signal_line\" in macd_result",
          "# assert \"histogram\" in macd_result",
          "# assert isinstance(macd_result[\"macd_line\"], (int, float))",
          "# assert isinstance(macd_result[\"signal_line\"], (int, float))",
          "# assert isinstance(macd_result[\"histogram\"], (int, float))",
          "# assert \"upper_band\" in bb_result",
          "# assert \"middle_band\" in bb_result",
          "# assert \"lower_band\" in bb_result",
          "# assert bb_result[\"upper_band\"] > bb_result[\"middle_band\"] > bb_result[\"lower_band\"]",
          "assert len(sma_values) == len(trend_price_data)",
          "assert isinstance(sma, (int, float))",
          "assert sma > 0",
          "assert len(ema_values) == len(trend_price_data)",
          "#     assert indicator in analysis",
          "assert processing_time < 1.0",
          "assert allocation[\"conservative\"] == Decimal(\"0.3\")",
          "assert allocation[\"moderate\"] == Decimal(\"0.5\")",
          "assert allocation[\"aggressive\"] == Decimal(\"0.2\")",
          "assert sum(allocation.values()) == Decimal(\"1.0\")",
          "assert allocation[\"conservative_amount\"] == expected_conservative",
          "assert allocation[\"moderate_amount\"] == expected_moderate",
          "assert allocation[\"aggressive_amount\"] == expected_aggressive",
          "assert performance[\"total_unrealized_pnl\"] == expected_total_pnl",
          "assert performance[\"pnl_percentage\"] == expected_pnl_percentage",
          "assert performance[\"total_value\"] == fund_manager.total_funds + expected_total_pnl",
          "assert \"strategy_performance\" in performance",
          "assert \"moderate\" in strategy_perf",
          "assert \"aggressive\" in strategy_perf",
          "assert \"conservative\" in strategy_perf",
          "assert sum(new_allocation.values()) == Decimal(\"1.0\")",
          "assert new_allocation[\"aggressive\"] > fund_manager.initial_allocation[\"aggressive\"]",
          "assert new_allocation[\"conservative\"] < fund_manager.initial_allocation[\"conservative\"]",
          "assert abs(new_allocation[strategy] - initial) <= max_change",
          "assert \"adjustments\" in adjustment",
          "assert \"reasoning\" in adjustment",
          "assert adjustment[\"adjustments\"][\"aggressive\"][\"direction\"] == \"increase\"",
          "assert adjustment[\"adjustments\"][\"aggressive\"][\"magnitude\"] > 0",
          "assert \"risk_level\" in risk_adjustment",
          "assert \"adjustments\" in risk_adjustment",
          "assert risk_adjustment[\"adjustments\"][\"aggressive\"][\"direction\"] == \"decrease\"",
          "assert risk_adjustment[\"adjustments\"][\"conservative\"][\"direction\"] == \"increase\"",
          "assert \"adjustments\" in volatility_adjustment",
          "assert volatility_adjustment[\"adjustments\"][\"aggressive\"][\"direction\"] == \"decrease\"",
          "assert volatility_adjustment[\"adjustments\"][\"conservative\"][\"direction\"] == \"increase\"",
          "assert \"adjustments\" in correlation_adjustment",
          "assert \"diversification_score\" in correlation_adjustment",
          "assert correlation_adjustment[\"diversification_score\"] < 1.0",
          "assert \"adjustments\" in liquidity_adjustment",
          "assert liquidity_adjustment[\"adjustments\"][\"conservative\"][\"direction\"] == \"increase\"",
          "assert liquidity_adjustment[\"adjustments\"][\"aggressive\"][\"direction\"] == \"decrease\"",
          "assert \"adjustments\" in bull_adjustment",
          "assert \"market_regime\" in bull_adjustment",
          "assert bull_adjustment[\"adjustments\"][\"aggressive\"][\"direction\"] == \"increase\"",
          "assert bear_adjustment[\"adjustments\"][\"conservative\"][\"direction\"] == \"increase\"",
          "assert \"final_allocation\" in combined_adjustment",
          "assert \"adjustment_factors\" in combined_adjustment",
          "assert \"confidence_score\" in combined_adjustment",
          "assert sum(combined_adjustment[\"final_allocation\"].values()) == Decimal(\"1.0\")",
          "assert is_valid[\"valid\"]",
          "assert is_valid[\"reason\"] == \"Allocation change within limits\"",
          "assert not is_invalid[\"valid\"]",
          "assert \"conservative\" in [error[\"strategy\"] for error in is_invalid[\"errors\"]]",
          "assert corrected[\"conservative\"] >= min_allocations[\"conservative\"]",
          "assert corrected[\"moderate\"] >= min_allocations[\"moderate\"]",
          "assert corrected[\"aggressive\"] >= min_allocations[\"aggressive\"]",
          "assert sum(corrected.values()) == Decimal(\"1.0\")",
          "assert corrected[\"conservative\"] <= max_allocations[\"conservative\"]",
          "assert corrected[\"moderate\"] <= max_allocations[\"moderate\"]",
          "assert corrected[\"aggressive\"] <= max_allocations[\"aggressive\"]",
          "assert len(history) == 1",
          "assert record[\"from_allocation\"] == initial_allocation",
          "assert record[\"to_allocation\"] == new_allocation",
          "assert record[\"reason\"] == \"performance_based_rebalancing\"",
          "assert len(performance_history) == 2",
          "assert \"average_return\" in metrics",
          "assert \"sharpe_ratio\" in metrics",
          "assert \"max_drawdown\" in metrics",
          "assert should_rebalance[\"should_rebalance\"]",
          "assert \"performance_based\" in should_rebalance[\"triggers\"]",
          "assert \"success\" in rebalance_result",
          "assert \"new_allocation\" in rebalance_result",
          "assert \"execution_time\" in rebalance_result",
          "assert current_allocation == rebalance_result[\"new_allocation\"]",
          "assert conservative_allocation[\"conservative\"] >= 0.6",
          "assert conservative_allocation[\"aggressive\"] <= 0.1",
          "assert aggressive_allocation[\"aggressive\"] >= 0.6",
          "assert aggressive_allocation[\"conservative\"] <= 0.1",
          "assert abs(balanced_allocation[\"conservative\"] - 0.33) < 0.05",
          "assert abs(balanced_allocation[\"aggressive\"] - 0.33) < 0.05",
          "assert \"adjustments\" in emergency_adjustment",
          "assert \"urgency_level\" in emergency_adjustment",
          "assert emergency_adjustment[\"adjustments\"][\"conservative\"][\"direction\"] == \"increase\"",
          "assert emergency_adjustment[\"adjustments\"][\"conservative\"][\"magnitude\"] > 0.2",
          "assert \"optimized_allocation\" in optimization_result",
          "assert \"expected_improvement\" in optimization_result",
          "assert \"optimization_method\" in optimization_result",
          "assert sum(optimized.values()) == Decimal(\"1.0\")",
          "assert \"total_return\" in backtest_result",
          "assert \"sharpe_ratio\" in backtest_result",
          "assert \"max_drawdown\" in backtest_result",
          "assert \"rebalance_count\" in backtest_result",
          "assert \"win_rate\" in stats",
          "assert \"average_rebalance_cost\" in stats",
          "assert allocation.strategy_type == \"moderate\"",
          "assert allocation.allocation_percent == Decimal(\"0.5\")",
          "assert allocation.allocated_amount == Decimal(\"50000.0\")",
          "assert allocation1.is_larger_than(allocation2)",
          "assert not allocation2.is_larger_than(allocation1)",
          "assert calculated_amount == Decimal(\"25000.0\")",
          "assert allocation.allocation_percent == new_percent",
          "assert allocation.allocated_amount == total_funds * new_percent",
          "assert metrics.period == \"30d\"",
          "assert metrics.total_return == Decimal(\"0.05\")",
          "assert metrics.sharpe_ratio == Decimal(\"1.2\")",
          "assert abs(calculated_sharpe - expected_sharpe) < Decimal(\"0.01\")",
          "assert abs(calculated_drawdown - expected_drawdown) < Decimal(\"0.0001\")",
          "assert abs(calculated_calmar - expected_calmar) < Decimal(\"0.01\")",
          "assert abs(calculated_ir - expected_ir) < Decimal(\"0.01\")",
          "assert performance[\"total_unrealized_pnl\"] == Decimal(\"0\")",
          "assert performance[\"total_value\"] == fund_manager.total_funds",
          "assert \"final_allocation\" in rebalance_result",
          "assert adjustment[\"adjustments\"][\"moderate\"][\"direction\"] == \"maintain\"",
          "assert profit_adjustment[\"adjustments\"][\"aggressive\"][\"direction\"] == \"increase\"",
          "assert loss_adjustment[\"adjustments\"][\"conservative\"][\"direction\"] == \"increase\"",
          "assert len(history) == 5",
          "assert len(filtered_news) == 2",
          "assert all(news[\"relevance_score\"] >= 0.7 for news in filtered_news)",
          "assert len(recent_news) == 2",
          "assert all(news[\"published_at\"] >= fifteen_days_ago for news in recent_news)",
          "assert len(scores) == 2",
          "assert scores[0] > scores[1]  # 第一个新闻质量更高",
          "assert len(deduplicated_news) == 2",
          "assert len(set(news[\"id\"] for news in deduplicated_news)) == 2",
          "assert len(sentiments) == 4",
          "assert sentiments[0] == \"positive\"",
          "assert sentiments[1] == \"negative\"",
          "assert sentiments[2] == \"neutral\"",
          "assert sentiments[3] == \"negative\"",
          "assert len(sorted_news) == 4",
          "assert sorted_news[0][\"relevance_score\"] == 0.95",
          "assert sorted_news[1][\"relevance_score\"] == 0.9",
          "assert sorted_news[2][\"relevance_score\"] == 0.7",
          "assert sorted_news[3][\"relevance_score\"] == 0.3",
          "assert len(categories) == 4",
          "assert categories.count(\"crypto\") == 2",
          "assert categories.count(\"mainstream\") == 1",
          "assert categories.count(\"other\") == 1",
          "assert len(limited_news) == max_news",
          "assert all(news[\"id\"] in [str(i) for i in range(max_news)] for news in limited_news)",
          "assert is_relevant == expected_filter",
          "assert len(aggregated) == 2",
          "assert len(aggregated[\"CoinDesk\"]) == 3",
          "assert len(aggregated[\"CryptoNews\"]) == 2",
          "assert all(isinstance(news_list, list) for news_list in aggregated.values())"
        ],
        "mock_usage": [
          "from unittest.mock import Mock, AsyncMock, patch",
          "from unittest.mock import Mock, AsyncMock, patch"
        ],
        "fixtures": [
          "@pytest.fixture",
          "@pytest.fixture",
          "@pytest.fixture",
          "@pytest.mark.asyncio",
          "@pytest.fixture",
          "@pytest.fixture",
          "@pytest.fixture",
          "@pytest.fixture",
          "@pytest.fixture",
          "@pytest.fixture",
          "@pytest.fixture",
          "@pytest.fixture",
          "@pytest.fixture",
          "@pytest.mark.parametrize(\"relevance_score,expected_filter\", ["
        ],
        "imports": [
          "import pytest",
          "from datetime import datetime, timedelta",
          "from decimal import Decimal",
          "import asyncio",
          "from backend.src.services.risk_manager import RiskManager, RiskLevel, RiskAssessment",
          "from backend.src.models.trading_order import OrderStatus, OrderType, OrderSide",
          "from backend.src.models.position import PositionSide",
          "from backend.src.models.trading_strategy import TradingStrategy",
          "import time",
          "import pytest",
          "import numpy as np",
          "import pandas as pd",
          "from datetime import datetime, timedelta",
          "from typing import List, Dict, Any",
          "from backend.src.services.technical_analysis_engine import TechnicalAnalysisEngine",
          "from backend.src.services.technical_analysis_engine import TechnicalAnalysisEngine",
          "from backend.src.services.technical_analysis_engine import TechnicalAnalysisEngine",
          "from backend.src.services.technical_analysis_engine import TechnicalAnalysisEngine",
          "from backend.src.services.technical_analysis_engine import TechnicalAnalysisEngine",
          "from backend.src.services.technical_analysis_engine import TechnicalAnalysisEngine",
          "import time",
          "import pytest",
          "from datetime import datetime, timedelta",
          "from decimal import Decimal",
          "import asyncio",
          "from backend.src.services.dynamic_fund_manager import (",
          "from backend.src.models.position import PositionSide",
          "import pytest",
          "from datetime import datetime, timedelta",
          "from typing import List, Dict, Any"
        ]
      }
    }
  },
  "file_analysis": {},
  "structure_analysis": {
    "directories": [],
    "python_files": [
      "src/main.py",
      "src/__init__.py",
      "src/tasks/news_tasks.py",
      "src/tasks/monitoring_tasks.py",
      "src/tasks/trading_tasks.py",
      "src/tasks/order_monitor.py",
      "src/tasks/celery_app.py",
      "src/tasks/__init__.py",
      "src/tasks/analysis_tasks.py",
      "src/api/__init__.py",
      "src/api/endpoints/auth.py",
      "src/api/endpoints/trading.py",
      "src/api/endpoints/strategies.py",
      "src/api/endpoints/news.py",
      "src/api/endpoints/__init__.py",
      "src/api/endpoints/monitoring.py",
      "src/core/llm_integration.py",
      "src/core/news_validation.py",
      "src/core/config.py",
      "src/core/trading_logging.py",
      "src/core/logging.py",
      "src/core/trading_validation.py",
      "src/core/news_events.py",
      "src/core/short_strategy_validation.py",
      "src/core/exchange_integration.py",
      "src/core/__init__.py",
      "src/core/exceptions.py",
      "src/core/short_strategy_logging.py",
      "src/core/cache.py",
      "src/models/base.py",
      "src/models/position.py",
      "src/models/trading_order.py",
      "src/models/trading.py",
      "src/models/user.py",
      "src/models/market.py",
      "src/models/news.py",
      "src/models/__init__.py",
      "src/models/technical_analysis.py",
      "src/models/trading_strategy.py",
      "src/services/order_manager.py",
      "src/services/news_filter.py",
      "src/services/llm_strategy_generator.py",
      "src/services/strategy_aggregator.py",
      "src/services/llm_news_summarizer.py",
      "src/services/news_collector.py",
      "src/services/technical_analysis_engine.py",
      "src/services/risk_manager.py",
      "src/services/exchange_data_collector.py",
      "src/services/llm_long_strategy_analyzer.py",
      "src/services/position_monitor.py",
      "src/services/__init__.py",
      "src/services/trading_executor.py",
      "src/services/llm_short_strategy_analyzer.py",
      "src/services/dynamic_fund_manager.py",
      "src/constitution/principles.py",
      "src/constitution/validator.py",
      "src/constitution/__init__.py",
      "tests/__init__.py",
      "tests/conftest.py",
      "tests/unit/test_risk_management.py",
      "tests/unit/test_technical_analysis.py",
      "tests/unit/test_dynamic_fund_manager.py",
      "tests/unit/test_news_filter.py",
      "tests/unit/__init__.py",
      "tests/contract/test_order_execution.py",
      "tests/contract/test_strategy_generation.py",
      "tests/contract/test_long_analysis.py",
      "tests/contract/test_short_analysis.py",
      "tests/contract/__init__.py",
      "tests/contract/test_news.py",
      "tests/integration/test_trading_workflow.py",
      "tests/integration/test_complete_workflow.py",
      "tests/integration/test_long_strategy.py",
      "tests/integration/test_short_strategy.py",
      "tests/integration/__init__.py",
      "tests/integration/test_news_workflow.py",
      "alembic/env.py",
      "alembic/versions/0001_initial_migration.py"
    ],
    "service_files": [
      "src/services/order_manager.py",
      "src/services/news_filter.py",
      "src/services/llm_strategy_generator.py",
      "src/services/strategy_aggregator.py",
      "src/services/llm_news_summarizer.py",
      "src/services/news_collector.py",
      "src/services/technical_analysis_engine.py",
      "src/services/risk_manager.py",
      "src/services/exchange_data_collector.py",
      "src/services/llm_long_strategy_analyzer.py",
      "src/services/position_monitor.py",
      "src/services/__init__.py",
      "src/services/trading_executor.py",
      "src/services/llm_short_strategy_analyzer.py",
      "src/services/dynamic_fund_manager.py"
    ],
    "model_files": [
      "src/models/base.py",
      "src/models/position.py",
      "src/models/trading_order.py",
      "src/models/trading.py",
      "src/models/user.py",
      "src/models/market.py",
      "src/models/news.py",
      "src/models/__init__.py",
      "src/models/technical_analysis.py",
      "src/models/trading_strategy.py"
    ],
    "test_files": [
      "tests/__init__.py",
      "tests/conftest.py",
      "tests/unit/test_risk_management.py",
      "tests/unit/test_technical_analysis.py",
      "tests/unit/test_dynamic_fund_manager.py",
      "tests/unit/test_news_filter.py",
      "tests/unit/__init__.py",
      "tests/contract/test_order_execution.py",
      "tests/contract/test_strategy_generation.py",
      "tests/contract/test_long_analysis.py",
      "tests/contract/test_short_analysis.py",
      "tests/contract/__init__.py",
      "tests/contract/test_news.py",
      "tests/integration/test_trading_workflow.py",
      "tests/integration/test_complete_workflow.py",
      "tests/integration/test_long_strategy.py",
      "tests/integration/test_short_strategy.py",
      "tests/integration/__init__.py",
      "tests/integration/test_news_workflow.py"
    ],
    "api_files": [
      "src/api/__init__.py",
      "src/api/endpoints/auth.py",
      "src/api/endpoints/trading.py",
      "src/api/endpoints/strategies.py",
      "src/api/endpoints/news.py",
      "src/api/endpoints/__init__.py",
      "src/api/endpoints/monitoring.py"
    ],
    "task_files": [
      "src/tasks/news_tasks.py",
      "src/tasks/monitoring_tasks.py",
      "src/tasks/trading_tasks.py",
      "src/tasks/order_monitor.py",
      "src/tasks/celery_app.py",
      "src/tasks/__init__.py",
      "src/tasks/analysis_tasks.py"
    ],
    "total_files": 78
  },
  "dependency_analysis": {
    "dependencies": {
      "fastapi": {
        "version": "0.104.1",
        "category": "web_framework"
      },
      "uvicorn[standard]": {
        "version": "0.24.0",
        "category": "web_framework"
      },
      "pydantic": {
        "version": "2.5.0",
        "category": "other"
      },
      "pydantic-settings": {
        "version": "2.1.0",
        "category": "other"
      },
      "sqlalchemy": {
        "version": "2.0.23",
        "category": "database"
      },
      "alembic": {
        "version": "1.13.0",
        "category": "other"
      },
      "asyncpg": {
        "version": "0.29.0",
        "category": "database"
      },
      "psycopg2-binary": {
        "version": "2.9.9",
        "category": "other"
      },
      "redis": {
        "version": "5.0.1",
        "category": "cache"
      },
      "celery": {
        "version": "5.3.4",
        "category": "task_queue"
      },
      "ccxt": {
        "version": "4.1.0",
        "category": "exchange"
      },
      "aiohttp": {
        "version": "3.9.1",
        "category": "exchange"
      },
      "openai": {
        "version": "1.3.0",
        "category": "llm"
      },
      "anthropic": {
        "version": "0.7.0",
        "category": "llm"
      },
      "langchain": {
        "version": "0.0.350",
        "category": "llm"
      },
      "langchain-openai": {
        "version": "0.0.2",
        "category": "llm"
      },
      "langchain-anthropic": {
        "version": "0.0.3",
        "category": "llm"
      },
      "pandas": {
        "version": "2.1.4",
        "category": "data_processing"
      },
      "numpy": {
        "version": "1.25.2",
        "category": "data_processing"
      },
      "aioredis": {
        "version": "2.0.1",
        "category": "cache"
      },
      "python-jose[cryptography]": {
        "version": "3.3.0",
        "category": "other"
      },
      "passlib[bcrypt]": {
        "version": "1.7.4",
        "category": "other"
      },
      "python-multipart": {
        "version": "0.0.6",
        "category": "other"
      },
      "pytest": {
        "version": "7.4.3",
        "category": "testing"
      },
      "pytest-asyncio": {
        "version": "0.21.1",
        "category": "testing"
      },
      "pytest-cov": {
        "version": "4.1.0",
        "category": "testing"
      },
      "httpx": {
        "version": "0.25.2",
        "category": "other"
      },
      "respx": {
        "version": "0.20.2",
        "category": "other"
      },
      "locust": {
        "version": "2.17.0",
        "category": "other"
      },
      "black": {
        "version": "23.11.0",
        "category": "development"
      },
      "isort": {
        "version": "5.12.0",
        "category": "development"
      },
      "mypy": {
        "version": "1.7.1",
        "category": "development"
      },
      "flake8": {
        "version": "6.1.0",
        "category": "other"
      },
      "prometheus-client": {
        "version": "0.19.0",
        "category": "other"
      },
      "structlog": {
        "version": "23.2.0",
        "category": "other"
      },
      "python-dotenv": {
        "version": "1.0.0",
        "category": "other"
      },
      "pyyaml": {
        "version": "6.0.1",
        "category": "other"
      },
      "click": {
        "version": "8.1.7",
        "category": "other"
      },
      "pyproject.toml": {
        "status": "exists"
      }
    },
    "total_dependencies": 39,
    "categories": {
      "web_framework": 2,
      "other": 17,
      "database": 2,
      "cache": 2,
      "task_queue": 1,
      "exchange": 2,
      "llm": 5,
      "data_processing": 2,
      "testing": 3,
      "development": 3
    }
  },
  "summary": {
    "test_files_count": 14,
    "test_methods_count": 190,
    "assertions_count": 645,
    "python_files_count": 78,
    "service_files_count": 15,
    "model_files_count": 10,
    "api_files_count": 7,
    "dependencies_count": 39,
    "syntax_check": {
      "total_files": 78,
      "passed_files": 75,
      "failed_files": 3,
      "errors": [
        {
          "file": "src/tasks/news_tasks.py",
          "error": "'await' outside async function (news_tasks.py, line 180)",
          "line": 180
        },
        {
          "file": "src/tasks/order_monitor.py",
          "error": "'await' outside async function (order_monitor.py, line 83)",
          "line": 83
        },
        {
          "file": "src/tasks/celery_app.py",
          "error": "keyword argument repeated: worker_prefetch_multiplier (celery_app.py, line 86)",
          "line": 86
        }
      ]
    },
    "test_coverage": {
      "contract_tests": 5,
      "integration_tests": 5,
      "unit_tests": 4
    }
  }
}