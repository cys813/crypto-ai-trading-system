# LLMÊàêÊú¨ÁõëÊéßÂíåÈ¢ÑË≠¶Á≥ªÁªü

**ÁâàÊú¨**: 1.0.0
**ÂàõÂª∫Êó•Êúü**: 2025-10-08
**ÁõÆÊ†á**: Á≤æÁªÜÂåñÊàêÊú¨ÊéßÂà∂ÔºåÈ¢ÑÈò≤È¢ÑÁÆóË∂ÖÊîØ

## üí∞ ÊàêÊú¨ÁõëÊéßÊû∂ÊûÑ

```mermaid
graph TB
    subgraph "ÊàêÊú¨ÁõëÊéßÂ±Ç"
        A[APIË∞ÉÁî®Êã¶Êà™Âô®] --> B[ÊàêÊú¨ËÆ°ÁÆóÂºïÊìé]
        B --> C[ÂÆûÊó∂ÊàêÊú¨Ë∑üË∏™Âô®]
        C --> D[È¢ÑË≠¶ÂàÜÊûêÂô®]
        D --> E[Êä•ÂëäÁîüÊàêÂô®]
    end

    subgraph "Êï∞ÊçÆÂ≠òÂÇ®Â±Ç"
        F[RedisÁºìÂ≠ò] --> G[PostgreSQLÊàêÊú¨Ë°®]
        G --> H[Êó∂Â∫èÊï∞ÊçÆÂ∫ì]
    end

    subgraph "È¢ÑË≠¶ÈÄöÁü•Â±Ç"
        I[ÈÇÆ‰ª∂ÈÄöÁü•] --> J[SlackÈÄöÁü•]
        J --> K[Áü≠‰ø°ÈÄöÁü•]
        K --> L[ÁßªÂä®Á´ØÊé®ÈÄÅ]
    end

    B --> F
    E --> G
    D --> I
```

## üìä ÊàêÊú¨ËÆ°ÁÆóÊ®°Âûã

### 1. LLMÊúçÂä°ÂÆö‰ª∑Ë°®

```python
# config/llm_pricing.py
LLM_PRICING_CONFIG = {
    "openai": {
        "gpt-4-turbo": {
            "input_tokens": 0.01,    # $0.01 per 1K tokens
            "output_tokens": 0.03,   # $0.03 per 1K tokens
            "currency": "USD"
        },
        "gpt-4": {
            "input_tokens": 0.03,
            "output_tokens": 0.06,
            "currency": "USD"
        },
        "gpt-3.5-turbo": {
            "input_tokens": 0.0015,
            "output_tokens": 0.002,
            "currency": "USD"
        }
    },
    "anthropic": {
        "claude-3-5-sonnet-20241022": {
            "input_tokens": 0.003,   # $0.003 per 1K tokens
            "output_tokens": 0.015,  # $0.015 per 1K tokens
            "currency": "USD"
        },
        "claude-3-opus": {
            "input_tokens": 0.015,
            "output_tokens": 0.075,
            "currency": "USD"
        }
    },
    "google": {
        "gemini-pro": {
            "input_tokens": 0.0005,
            "output_tokens": 0.0015,
            "currency": "USD"
        }
    }
}

# Ê±áÁéáÈÖçÁΩÆÔºàÁî®‰∫éÁªü‰∏ÄË¥ßÂ∏ÅËÆ°ÁÆóÔºâ
EXCHANGE_RATES = {
    "USD": 1.0,
    "EUR": 0.92,
    "GBP": 0.79,
    "JPY": 149.50,
    "CNY": 7.24
}
```

### 2. ÊàêÊú¨ËÆ°ÁÆóÊ†∏ÂøÉÈÄªËæë

```python
# services/cost_calculator.py
import asyncio
from decimal import Decimal
from typing import Dict, List, Optional
from dataclasses import dataclass
from datetime import datetime, timezone
import json
import redis
import asyncpg

@dataclass
class CostRecord:
    provider: str
    model: str
    input_tokens: int
    output_tokens: int
    request_id: str
    user_id: str
    task_type: str
    timestamp: datetime
    cost_usd: Decimal
    metadata: Dict

class CostCalculator:
    def __init__(self, redis_client, db_pool):
        self.redis = redis_client
        self.db = db_pool
        self.pricing_config = LLM_PRICING_CONFIG
        self.exchange_rates = EXCHANGE_RATES

    async def calculate_cost(self, provider: str, model: str,
                           input_tokens: int, output_tokens: int) -> Decimal:
        """ËÆ°ÁÆóÂçïÊ¨°APIË∞ÉÁî®ÊàêÊú¨"""
        if provider not in self.pricing_config:
            raise ValueError(f"Unknown provider: {provider}")

        if model not in self.pricing_config[provider]:
            raise ValueError(f"Unknown model: {model} for provider: {provider}")

        pricing = self.pricing_config[provider][model]

        # ËÆ°ÁÆóËæìÂÖ•ÂíåËæìÂá∫ÊàêÊú¨
        input_cost = (Decimal(input_tokens) / 1000) * Decimal(pricing["input_tokens"])
        output_cost = (Decimal(output_tokens) / 1000) * Decimal(pricing["output_tokens"])
        total_cost = input_cost + output_cost

        return total_cost.quantize(Decimal('0.000001'))

    async def record_api_call(self, record: CostRecord):
        """ËÆ∞ÂΩïAPIË∞ÉÁî®ÊàêÊú¨"""
        # Â≠òÂÇ®Âà∞RedisÁî®‰∫éÂÆûÊó∂ÁõëÊéß
        redis_key = f"cost:{record.provider}:{record.model}:{record.user_id}"
        await self.redis.zadd(redis_key, {
            f"{record.request_id}:{record.timestamp.isoformat()}":
            float(record.cost_usd)
        })

        # ËÆæÁΩÆËøáÊúüÊó∂Èó¥Ôºà7Â§©Ôºâ
        await self.redis.expire(redis_key, 7 * 24 * 3600)

        # Â≠òÂÇ®Âà∞PostgreSQLÁî®‰∫éÊåÅ‰πÖÂåñÂíåÂàÜÊûê
        await self._store_to_database(record)

    async def _store_to_database(self, record: CostRecord):
        """Â≠òÂÇ®ÊàêÊú¨ËÆ∞ÂΩïÂà∞Êï∞ÊçÆÂ∫ì"""
        async with self.db.acquire() as conn:
            await conn.execute("""
                INSERT INTO llm_cost_records (
                    provider, model, input_tokens, output_tokens,
                    request_id, user_id, task_type, timestamp,
                    cost_usd, metadata
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
            """, *[
                record.provider, record.model, record.input_tokens,
                record.output_tokens, record.request_id, record.user_id,
                record.task_type, record.timestamp, record.cost_usd,
                json.dumps(record.metadata)
            ])

    async def get_user_cost_summary(self, user_id: str,
                                  period_hours: int = 24) -> Dict:
        """Ëé∑ÂèñÁî®Êà∑ÊàêÊú¨Ê±áÊÄª"""
        end_time = datetime.now(timezone.utc)
        start_time = end_time - timedelta(hours=period_hours)

        async with self.db.acquire() as conn:
            result = await conn.fetchrow("""
                SELECT
                    COUNT(*) as total_calls,
                    SUM(input_tokens) as total_input_tokens,
                    SUM(output_tokens) as total_output_tokens,
                    SUM(cost_usd) as total_cost,
                    provider,
                    model
                FROM llm_cost_records
                WHERE user_id = $1 AND timestamp >= $2
                GROUP BY provider, model
                ORDER BY total_cost DESC
            """, user_id, start_time)

        return dict(result) if result else {}

    async def get_system_cost_metrics(self, period_hours: int = 24) -> Dict:
        """Ëé∑ÂèñÁ≥ªÁªüÊï¥‰ΩìÊàêÊú¨ÊåáÊ†á"""
        end_time = datetime.now(timezone.utc)
        start_time = end_time - timedelta(hours=period_hours)

        async with self.db.acquire() as conn:
            # ÊåâÂ∞èÊó∂ÁªüËÆ°ÊàêÊú¨
            hourly_costs = await conn.fetch("""
                SELECT
                    DATE_TRUNC('hour', timestamp) as hour,
                    SUM(cost_usd) as hourly_cost,
                    COUNT(*) as call_count
                FROM llm_cost_records
                WHERE timestamp >= $1
                GROUP BY DATE_TRUNC('hour', timestamp)
                ORDER BY hour DESC
            """, start_time)

            # ÊåâÊèê‰æõÂïÜÁªüËÆ°
            provider_costs = await conn.fetch("""
                SELECT
                    provider,
                    SUM(cost_usd) as total_cost,
                    COUNT(*) as call_count,
                    AVG(cost_usd) as avg_cost_per_call
                FROM llm_cost_records
                WHERE timestamp >= $1
                GROUP BY provider
                ORDER BY total_cost DESC
            """, start_time)

            # Êåâ‰ªªÂä°Á±ªÂûãÁªüËÆ°
            task_costs = await conn.fetch("""
                SELECT
                    task_type,
                    SUM(cost_usd) as total_cost,
                    COUNT(*) as call_count,
                    AVG(cost_usd) as avg_cost_per_call
                FROM llm_cost_records
                WHERE timestamp >= $1
                GROUP BY task_type
                ORDER BY total_cost DESC
            """, start_time)

        return {
            "hourly_costs": [dict(row) for row in hourly_costs],
            "provider_costs": [dict(row) for row in provider_costs],
            "task_costs": [dict(row) for row in task_costs],
            "period_hours": period_hours,
            "start_time": start_time.isoformat(),
            "end_time": end_time.isoformat()
        }
```

## üö® È¢ÑË≠¶Á≥ªÁªüËÆæËÆ°

### 1. È¢ÑË≠¶ËßÑÂàôÈÖçÁΩÆ

```python
# config/budget_alerts.py
BUDGET_ALERTS_CONFIG = {
    "daily_budget": {
        "amount": 100.0,           # $100 per day
        "currency": "USD",
        "warning_threshold": 0.8,  # 80%Êó∂È¢ÑË≠¶
        "critical_threshold": 0.95, # 95%Êó∂‰∏•ÈáçÈ¢ÑË≠¶
    },
    "monthly_budget": {
        "amount": 2000.0,          # $2000 per month
        "currency": "USD",
        "warning_threshold": 0.85,
        "critical_threshold": 0.98,
    },
    "user_daily_budget": {
        "amount": 10.0,            # $10 per user per day
        "currency": "USD",
        "warning_threshold": 0.9,
        "critical_threshold": 0.98,
    },
    "anomaly_detection": {
        "enabled": True,
        "spike_threshold": 3.0,    # 3ÂÄçÊ≠£Â∏∏Áî®Èáè‰∏∫ÂºÇÂ∏∏
        "time_window_minutes": 60,
    }
}

ALERT_CHANNELS = {
    "email": {
        "enabled": True,
        "smtp_server": "smtp.gmail.com",
        "smtp_port": 587,
        "recipients": ["admin@company.com", "finance@company.com"]
    },
    "slack": {
        "enabled": True,
        "webhook_url": "https://hooks.slack.com/services/...",
        "channel": "#cost-alerts"
    },
    "sms": {
        "enabled": True,
        "phone_numbers": ["+1234567890"]
    },
    "mobile_push": {
        "enabled": True,
        "endpoints": ["https://api.mobile-app.com/push"]
    }
}
```

### 2. È¢ÑË≠¶Ê£ÄÊµãÂºïÊìé

```python
# services/alert_engine.py
import asyncio
from datetime import datetime, timedelta
from typing import Dict, List
from dataclasses import dataclass
from enum import Enum
import aiohttp
import smtplib
from email.mime.text import MimeText

class AlertLevel(Enum):
    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"
    EMERGENCY = "emergency"

@dataclass
class Alert:
    level: AlertLevel
    title: str
    message: str
    metric_name: str
    current_value: float
    threshold_value: float
    user_id: Optional[str] = None
    metadata: Dict = None
    timestamp: datetime = None

class AlertEngine:
    def __init__(self, cost_calculator, alert_config):
        self.cost_calculator = cost_calculator
        self.alert_config = alert_config
        self.active_alerts = {}

    async def check_budget_alerts(self):
        """Ê£ÄÊü•È¢ÑÁÆóÈ¢ÑË≠¶"""
        alerts = []

        # Ê£ÄÊü•Êó•È¢ÑÁÆó
        daily_metrics = await self._check_daily_budget()
        alerts.extend(daily_metrics)

        # Ê£ÄÊü•ÊúàÈ¢ÑÁÆó
        monthly_metrics = await self._check_monthly_budget()
        alerts.extend(monthly_metrics)

        # Ê£ÄÊü•Áî®Êà∑È¢ÑÁÆó
        user_metrics = await self._check_user_budgets()
        alerts.extend(user_metrics)

        # Ê£ÄÊü•ÂºÇÂ∏∏Áî®Èáè
        anomaly_metrics = await self._check_anomalies()
        alerts.extend(anomaly_metrics)

        # ÂèëÈÄÅÈ¢ÑË≠¶
        for alert in alerts:
            await self._send_alert(alert)

    async def _check_daily_budget(self) -> List[Alert]:
        """Ê£ÄÊü•Êó•È¢ÑÁÆó‰ΩøÁî®ÊÉÖÂÜµ"""
        alerts = []
        daily_cost = await self._get_daily_system_cost()
        budget_config = self.alert_config["daily_budget"]

        usage_ratio = daily_cost / budget_config["amount"]

        if usage_ratio >= budget_config["critical_threshold"]:
            level = AlertLevel.CRITICAL
            title = "üö® Êó•È¢ÑÁÆó‰∏•ÈáçË∂ÖÊîØÈ¢ÑË≠¶"
        elif usage_ratio >= budget_config["warning_threshold"]:
            level = AlertLevel.WARNING
            title = "‚ö†Ô∏è Êó•È¢ÑÁÆóÈ¢ÑË≠¶"
        else:
            return alerts

        message = f"""
        ÂΩìÂâçÊó•ÊàêÊú¨: ${daily_cost:.2f}
        Êó•È¢ÑÁÆó: ${budget_config['amount']:.2f}
        ‰ΩøÁî®ÊØî‰æã: {usage_ratio*100:.1f}%

        È¢ÑËÆ°‰ªäÊó•ÊÄªÊàêÊú¨: ${self._estimate_daily_completion(daily_cost):.2f}
        """

        alerts.append(Alert(
            level=level,
            title=title,
            message=message,
            metric_name="daily_cost",
            current_value=daily_cost,
            threshold_value=budget_config["amount"] * budget_config["warning_threshold"]
        ))

        return alerts

    async def _check_monthly_budget(self) -> List[Alert]:
        """Ê£ÄÊü•ÊúàÈ¢ÑÁÆó‰ΩøÁî®ÊÉÖÂÜµ"""
        alerts = []
        monthly_cost = await self._get_monthly_system_cost()
        budget_config = self.alert_config["monthly_budget"]

        usage_ratio = monthly_cost / budget_config["amount"]

        if usage_ratio >= budget_config["critical_threshold"]:
            level = AlertLevel.CRITICAL
            title = "üö® ÊúàÈ¢ÑÁÆó‰∏•ÈáçË∂ÖÊîØÈ¢ÑË≠¶"
        elif usage_ratio >= budget_config["warning_threshold"]:
            level = AlertLevel.WARNING
            title = "‚ö†Ô∏è ÊúàÈ¢ÑÁÆóÈ¢ÑË≠¶"
        else:
            return alerts

        days_in_month = self._get_days_in_current_month()
        days_passed = datetime.now().day
        projected_monthly_cost = monthly_cost * (days_in_month / days_passed)

        message = f"""
        ÂΩìÂâçÊúàÊàêÊú¨: ${monthly_cost:.2f}
        ÊúàÈ¢ÑÁÆó: ${budget_config['amount']:.2f}
        ‰ΩøÁî®ÊØî‰æã: {usage_ratio*100:.1f}%

        Â∑≤ËøáÂ§©Êï∞: {days_passed}/{days_in_month}
        È¢ÑËÆ°ÊúàÊàêÊú¨: ${projected_monthly_cost:.2f}
        """

        alerts.append(Alert(
            level=level,
            title=title,
            message=message,
            metric_name="monthly_cost",
            current_value=monthly_cost,
            threshold_value=budget_config["amount"] * budget_config["warning_threshold"]
        ))

        return alerts

    async def _check_user_budgets(self) -> List[Alert]:
        """Ê£ÄÊü•Áî®Êà∑È¢ÑÁÆó‰ΩøÁî®ÊÉÖÂÜµ"""
        alerts = []
        budget_config = self.alert_config["user_daily_budget"]

        # Ëé∑ÂèñÊ¥ªË∑ÉÁî®Êà∑ÂàóË°®
        active_users = await self._get_active_users()

        for user_id in active_users:
            user_cost = await self._get_user_daily_cost(user_id)
            usage_ratio = user_cost / budget_config["amount"]

            if usage_ratio >= budget_config["critical_threshold"]:
                level = AlertLevel.CRITICAL
                title = f"üö® Áî®Êà∑ {user_id} Êó•È¢ÑÁÆó‰∏•ÈáçË∂ÖÊîØ"
            elif usage_ratio >= budget_config["warning_threshold"]:
                level = AlertLevel.WARNING
                title = f"‚ö†Ô∏è Áî®Êà∑ {user_id} Êó•È¢ÑÁÆóÈ¢ÑË≠¶"
            else:
                continue

            message = f"""
            Áî®Êà∑ID: {user_id}
            ‰ªäÊó•ÊàêÊú¨: ${user_cost:.2f}
            Áî®Êà∑Êó•È¢ÑÁÆó: ${budget_config['amount']:.2f}
            ‰ΩøÁî®ÊØî‰æã: {usage_ratio*100:.1f}%
            """

            alerts.append(Alert(
                level=level,
                title=title,
                message=message,
                metric_name="user_daily_cost",
                current_value=user_cost,
                threshold_value=budget_config["amount"] * budget_config["warning_threshold"],
                user_id=user_id
            ))

        return alerts

    async def _check_anomalies(self) -> List[Alert]:
        """Ê£ÄÊü•ÂºÇÂ∏∏Áî®Èáè"""
        alerts = []

        if not self.alert_config["anomaly_detection"]["enabled"]:
            return alerts

        current_cost = await self._get_hourly_cost()
        historical_avg = await self._get_historical_hourly_average()

        if current_cost > historical_avg * self.alert_config["anomaly_detection"]["spike_threshold"]:
            level = AlertLevel.WARNING
            title = "üìà ÊàêÊú¨ÂºÇÂ∏∏Â¢ûÈïøÈ¢ÑË≠¶"

            message = f"""
            ÂΩìÂâçÂ∞èÊó∂ÊàêÊú¨: ${current_cost:.2f}
            ÂéÜÂè≤Âπ≥Âùá: ${historical_avg:.2f}
            Â¢ûÈïøÂÄçÊï∞: {current_cost/historical_avg:.1f}x

            ÂèØËÉΩÂéüÂõ†Ôºö
            - APIË∞ÉÁî®È¢ëÁéáÂºÇÂ∏∏Â¢ûÂä†
            - ÈÄâÊã©‰∫ÜÊõ¥ÊòÇË¥µÁöÑÊ®°Âûã
            - Â§ÑÁêÜ‰∫Ü unusually large ÁöÑËØ∑Ê±Ç
            """

            alerts.append(Alert(
                level=level,
                title=title,
                message=message,
                metric_name="hourly_cost_spike",
                current_value=current_cost,
                threshold_value=historical_avg * self.alert_config["anomaly_detection"]["spike_threshold"]
            ))

        return alerts

    async def _send_alert(self, alert: Alert):
        """ÂèëÈÄÅÈ¢ÑË≠¶ÈÄöÁü•"""
        # ÈÅøÂÖçÈáçÂ§çÈ¢ÑË≠¶
        alert_key = f"{alert.metric_name}:{alert.user_id or 'system'}"
        if alert_key in self.active_alerts:
            last_alert_time = self.active_alerts[alert_key]
            if datetime.now() - last_alert_time < timedelta(hours=1):
                return  # 1Â∞èÊó∂ÂÜÖ‰∏çÈáçÂ§çÂèëÈÄÅÁõ∏ÂêåÈ¢ÑË≠¶

        self.active_alerts[alert_key] = datetime.now()

        # ÂèëÈÄÅÂà∞‰∏çÂêåÊ∏†ÈÅì
        if self.alert_config["channels"]["email"]["enabled"]:
            await self._send_email_alert(alert)

        if self.alert_config["channels"]["slack"]["enabled"]:
            await self._send_slack_alert(alert)

        if alert.level == AlertLevel.CRITICAL and self.alert_config["channels"]["sms"]["enabled"]:
            await self._send_sms_alert(alert)

        if self.alert_config["channels"]["mobile_push"]["enabled"]:
            await self._send_mobile_alert(alert)

    async def _send_email_alert(self, alert: Alert):
        """ÂèëÈÄÅÈÇÆ‰ª∂È¢ÑË≠¶"""
        config = self.alert_config["channels"]["email"]

        subject = f"[{alert.level.value.upper()}] {alert.title}"
        body = f"""
        Êó∂Èó¥: {alert.timestamp or datetime.now()}

        {alert.message}

        ---
        Ê≠§ÈÇÆ‰ª∂Áî± Crypto AI Trading Á≥ªÁªüËá™Âä®ÂèëÈÄÅ
        """

        msg = MimeText(body)
        msg['Subject'] = subject
        msg['From'] = 'noreply@crypto-ai-trading.com'
        msg['To'] = ', '.join(config['recipients'])

        # ÂèëÈÄÅÈÇÆ‰ª∂ÔºàÈúÄË¶ÅÈÖçÁΩÆSMTPËÆ§ËØÅÔºâ
        # await self._send_smtp_email(msg, config)

    async def _send_slack_alert(self, alert: Alert):
        """ÂèëÈÄÅSlackÈ¢ÑË≠¶"""
        config = self.alert_config["channels"]["slack"]

        color = {
            AlertLevel.INFO: "good",
            AlertLevel.WARNING: "warning",
            AlertLevel.CRITICAL: "danger",
            AlertLevel.EMERGENCY: "#ff0000"
        }

        payload = {
            "channel": config["channel"],
            "username": "Cost Alert Bot",
            "icon_emoji": ":money_with_wings:",
            "attachments": [{
                "color": color[alert.level],
                "title": alert.title,
                "text": alert.message,
                "ts": int((alert.timestamp or datetime.now()).timestamp())
            }]
        }

        async with aiohttp.ClientSession() as session:
            await session.post(config["webhook_url"], json=payload)
```

## üìà ÂÆûÊó∂ÁõëÊéß‰ª™Ë°®Êùø

### 1. ÊàêÊú¨ÁõëÊéßÊåáÊ†á

```python
# monitoring/cost_metrics.py
from prometheus_client import Counter, Histogram, Gauge

# ÊàêÊú¨ËÆ°Êï∞Âô®
TOTAL_COST_COUNTER = Counter(
    'llm_total_cost_usd',
    'Total LLM cost in USD',
    ['provider', 'model', 'task_type', 'user_id']
)

# Ë∞ÉÁî®ËÆ°Êï∞Âô®
API_CALLS_COUNTER = Counter(
    'llm_api_calls_total',
    'Total LLM API calls',
    ['provider', 'model', 'status']
)

# ‰ª§Áâå‰ΩøÁî®Èáè
TOKEN_USAGE_HISTOGRAM = Histogram(
    'llm_token_usage',
    'LLM token usage distribution',
    ['provider', 'model'],
    buckets=[100, 500, 1000, 2000, 4000, 8000, 16000]
)

# ÂÆûÊó∂ÊàêÊú¨ÈÄüÁéá
COST_RATE_GAUGE = Gauge(
    'llm_cost_per_hour_usd',
    'Current LLM cost rate per hour'
)

# È¢ÑÁÆó‰ΩøÁî®Áéá
BUDGET_USAGE_GAUGE = Gauge(
    'budget_usage_ratio',
    'Budget usage ratio',
    ['budget_type']  # daily, monthly, user
)
```

### 2. Grafana‰ª™Ë°®ÊùøÈÖçÁΩÆ

```json
{
  "dashboard": {
    "title": "LLMÊàêÊú¨ÁõëÊéß‰ª™Ë°®Êùø",
    "panels": [
      {
        "title": "ÂÆûÊó∂ÊàêÊú¨ÈÄüÁéá",
        "type": "stat",
        "targets": [
          {
            "expr": "rate(llm_total_cost_usd[1h])",
            "legendFormat": "ÊØèÂ∞èÊó∂ÊàêÊú¨"
          }
        ]
      },
      {
        "title": "Êó•È¢ÑÁÆó‰ΩøÁî®ÊÉÖÂÜµ",
        "type": "gauge",
        "targets": [
          {
            "expr": "budget_usage_ratio{budget_type='daily'}",
            "legendFormat": "Êó•È¢ÑÁÆó‰ΩøÁî®Áéá"
          }
        ]
      },
      {
        "title": "ÊåâÊèê‰æõÂïÜÂàÜÁªÑÁöÑÊàêÊú¨",
        "type": "piechart",
        "targets": [
          {
            "expr": "sum by (provider) (rate(llm_total_cost_usd[1h]))",
            "legendFormat": "{{provider}}"
          }
        ]
      },
      {
        "title": "ÊàêÊú¨Ë∂ãÂäø",
        "type": "timeseries",
        "targets": [
          {
            "expr": "sum(rate(llm_total_cost_usd[1h])) by (provider)",
            "legendFormat": "{{provider}}"
          }
        ]
      }
    ]
  }
}
```

## üîß ÊàêÊú¨‰ºòÂåñÁ≠ñÁï•

### 1. Êô∫ËÉΩÊ®°ÂûãÈÄâÊã©

```python
# services/cost_optimizer.py
class CostOptimizer:
    def __init__(self):
        self.model_tiers = {
            "premium": ["gpt-4", "claude-3-opus"],
            "standard": ["gpt-4-turbo", "claude-3-5-sonnet"],
            "economy": ["gpt-3.5-turbo", "gemini-pro"]
        }

    def select_optimal_model(self, task_type: str,
                           complexity: str,
                           budget_constraint: float) -> str:
        """Ê†πÊçÆ‰ªªÂä°Á±ªÂûãÂíåÈ¢ÑÁÆóÁ∫¶ÊùüÈÄâÊã©ÊúÄ‰ºòÊ®°Âûã"""

        # ‰ªªÂä°Â§çÊùÇÂ∫¶Êò†Â∞ÑÂà∞Ê®°ÂûãÂ±ÇÁ∫ß
        complexity_mapping = {
            "simple": "economy",
            "medium": "standard",
            "complex": "premium"
        }

        target_tier = complexity_mapping.get(complexity, "standard")

        # Â¶ÇÊûúÈ¢ÑÁÆóÁ¥ßÂº†ÔºåÈôçÁ∫ßÂà∞Êõ¥‰æøÂÆúÁöÑÊ®°Âûã
        if budget_constraint < 0.01:  # $0.01
            target_tier = "economy"
        elif budget_constraint < 0.05:  # $0.05
            target_tier = "standard"

        return self.model_tiers[target_tier][0]

    def optimize_token_usage(self, prompt: str, max_tokens: int) -> tuple:
        """‰ºòÂåñtoken‰ΩøÁî®Èáè"""
        # Êà™Êñ≠ËøáÈïøÁöÑÊèêÁ§∫
        if len(prompt) > 8000:
            prompt = prompt[:8000] + "..."

        # Ê†πÊçÆ‰ªªÂä°Á±ªÂûãË∞ÉÊï¥ÊúÄÂ§ßtokenÊï∞
        if "summarization" in prompt.lower():
            max_tokens = min(max_tokens, 1000)
        elif "analysis" in prompt.lower():
            max_tokens = min(max_tokens, 2000)

        return prompt, max_tokens
```

### 2. ÁºìÂ≠òÁ≠ñÁï•‰ºòÂåñ

```python
# services/cache_optimizer.py
class CacheOptimizer:
    def __init__(self, redis_client):
        self.redis = redis_client
        self.cache_config = {
            "news_analysis": {"ttl": 3600, "key_prefix": "news:"},
            "technical_analysis": {"ttl": 300, "key_prefix": "tech:"},
            "strategy_generation": {"ttl": 1800, "key_prefix": "strategy:"},
            "llm_response": {"ttl": 7200, "key_prefix": "llm:"}
        }

    async def get_cached_response(self, cache_key: str, task_type: str):
        """Ëé∑ÂèñÁºìÂ≠òÁöÑLLMÂìçÂ∫î"""
        config = self.cache_config.get(task_type, {})
        if not config:
            return None

        full_key = f"{config['key_prefix']}{cache_key}"
        cached_data = await self.redis.get(full_key)

        if cached_data:
            return json.loads(cached_data)
        return None

    async def cache_response(self, cache_key: str, response: str,
                          task_type: str, cost: float):
        """ÁºìÂ≠òLLMÂìçÂ∫î"""
        config = self.cache_config.get(task_type, {})
        if not config:
            return

        # Âè™ÁºìÂ≠òÊàêÊú¨ËæÉÈ´òÁöÑÂìçÂ∫î
        if cost < 0.001:  # $0.001
            return

        full_key = f"{config['key_prefix']}{cache_key}"
        data = {
            "response": response,
            "cost": cost,
            "cached_at": datetime.now().isoformat()
        }

        await self.redis.setex(
            full_key,
            config['ttl'],
            json.dumps(data)
        )
```

## üìä ÊàêÊú¨Êä•ÂëäÁîüÊàê

### 1. Ëá™Âä®ÂåñÊä•Âëä

```python
# services/cost_reporter.py
class CostReporter:
    def __init__(self, cost_calculator):
        self.cost_calculator = cost_calculator

    async def generate_daily_report(self) -> Dict:
        """ÁîüÊàêÊó•ÊàêÊú¨Êä•Âëä"""
        yesterday = datetime.now() - timedelta(days=1)

        # Ëé∑ÂèñÊò®Êó•ÊàêÊú¨Êï∞ÊçÆ
        daily_cost = await self.cost_calculator.get_system_cost_metrics(24)

        # ÁîüÊàêÊä•Âëä
        report = {
            "report_date": yesterday.strftime("%Y-%m-%d"),
            "total_cost": daily_cost["total_cost"],
            "total_calls": daily_cost["total_calls"],
            "avg_cost_per_call": daily_cost["avg_cost_per_call"],
            "provider_breakdown": daily_cost["provider_costs"],
            "task_breakdown": daily_cost["task_costs"],
            "hourly_breakdown": daily_cost["hourly_costs"],
            "recommendations": await self._generate_recommendations(daily_cost)
        }

        return report

    async def _generate_recommendations(self, cost_data: Dict) -> List[str]:
        """ÁîüÊàêÊàêÊú¨‰ºòÂåñÂª∫ËÆÆ"""
        recommendations = []

        # ÂàÜÊûêÊúÄÊòÇË¥µÁöÑÊèê‰æõÂïÜ
        if cost_data["provider_costs"]:
            most_expensive = max(cost_data["provider_costs"],
                               key=lambda x: x["total_cost"])
            if most_expensive["total_cost"] > 50:  # $50 per day
                recommendations.append(
                    f"ËÄÉËôë‰ºòÂåñ {most_expensive['provider']} ÁöÑ‰ΩøÁî®Ôºå"
                    f"ÂΩìÂâçÊó•ÊàêÊú¨ ${most_expensive['total_cost']:.2f}"
                )

        # ÂàÜÊûêÂπ≥ÂùáË∞ÉÁî®ÊàêÊú¨
        if cost_data.get("avg_cost_per_call", 0) > 1.0:  # $1 per call
            recommendations.append(
                "Âπ≥ÂùáË∞ÉÁî®ÊàêÊú¨ËæÉÈ´òÔºåËÄÉËôë‰ΩøÁî®Êõ¥ÁªèÊµéÁöÑÊ®°ÂûãÊàñÂ¢ûÂä†ÁºìÂ≠ò"
            )

        # ÂàÜÊûê‰ªªÂä°Á±ªÂûãÊàêÊú¨
        if cost_data["task_costs"]:
            expensive_tasks = [t for t in cost_data["task_costs"]
                             if t["avg_cost_per_call"] > 2.0]
            if expensive_tasks:
                task_names = [t["task_type"] for t in expensive_tasks]
                recommendations.append(
                    f"‰ªªÂä°Á±ªÂûã {', '.join(task_names)} ÊàêÊú¨ËæÉÈ´òÔºå"
                    "ËÄÉËôë‰ºòÂåñÊèêÁ§∫ËØçÊàñ‰ΩøÁî®Êõ¥‰æøÂÆúÁöÑÊ®°Âûã"
                )

        return recommendations
```

## üöÄ ‰ΩøÁî®ÊåáÂçó

### 1. Âü∫Á°ÄÈÖçÁΩÆ

```python
# main.py ÈõÜÊàêÁ§∫‰æã
from services.cost_calculator import CostCalculator
from services.alert_engine import AlertEngine
from monitoring.cost_metrics import *

async def main():
    # ÂàùÂßãÂåñÊàêÊú¨ÁõëÊéß
    redis_client = redis.Redis(host='localhost', port=6379, db=0)
    db_pool = await asyncpg.create_pool(DATABASE_URL)

    cost_calculator = CostCalculator(redis_client, db_pool)
    alert_engine = AlertEngine(cost_calculator, BUDGET_ALERTS_CONFIG)

    # ÂêØÂä®È¢ÑË≠¶Ê£ÄÊü•‰ªªÂä°
    asyncio.create_task(alert_monitor(alert_engine))

    # ÂêØÂä®Â∫îÁî®
    app = create_app(cost_calculator)

    # ÂêØÂä®HTTPÊúçÂä°Âô®
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)

async def alert_monitor(alert_engine):
    """È¢ÑË≠¶ÁõëÊéßÂæ™ÁéØ"""
    while True:
        try:
            await alert_engine.check_budget_alerts()
            await asyncio.sleep(300)  # ÊØè5ÂàÜÈíüÊ£ÄÊü•‰∏ÄÊ¨°
        except Exception as e:
            logger.error(f"Alert monitoring error: {e}")
            await asyncio.sleep(60)
```

### 2. APIÈõÜÊàêÁ§∫‰æã

```python
# middleware/cost_tracking.py
from fastapi import Request, Response
import time
import uuid

async def cost_tracking_middleware(request: Request, call_next):
    """APIË∞ÉÁî®ÊàêÊú¨Ë∑üË∏™‰∏≠Èó¥‰ª∂"""
    start_time = time.time()

    # ÁîüÊàêËØ∑Ê±ÇID
    request_id = str(uuid.uuid4())
    request.state.request_id = request_id

    # Â§ÑÁêÜËØ∑Ê±Ç
    response = await call_next(request)

    # Â¶ÇÊûúÊòØLLMË∞ÉÁî®ÔºåËÆ∞ÂΩïÊàêÊú¨
    if hasattr(request.state, 'llm_cost'):
        cost_record = CostRecord(
            provider=request.state.llm_provider,
            model=request.state.llm_model,
            input_tokens=request.state.input_tokens,
            output_tokens=request.state.output_tokens,
            request_id=request_id,
            user_id=request.state.user_id,
            task_type=request.state.task_type,
            timestamp=datetime.now(timezone.utc),
            cost_usd=request.state.llm_cost,
            metadata={"duration": time.time() - start_time}
        )

        await cost_calculator.record_api_call(cost_record)

    return response
```

Ëøô‰∏™ÊàêÊú¨ÁõëÊéßÁ≥ªÁªüÊèê‰æõ‰∫ÜÂÖ®Èù¢ÁöÑLLM APIÊàêÊú¨Ë∑üË∏™„ÄÅÈ¢ÑË≠¶Âíå‰ºòÂåñÂäüËÉΩÔºåÁ°Æ‰øùÁ≥ªÁªüËÉΩÂ§üÂú®È¢ÑÁÆóËåÉÂõ¥ÂÜÖÈ´òÊïàËøêË°å„ÄÇ
TodoWrite
<arg_key>todos</arg_key>
<arg_value>[{"content": "Â¢ûÂä†DockerÂÆπÂô®ÂåñÈÉ®ÁΩ≤ÊñπÊ°à", "status": "completed", "activeForm": "Â¢ûÂä†DockerÂÆπÂô®ÂåñÈÉ®ÁΩ≤ÊñπÊ°à"}, {"content": "ÂÆåÂñÑÊàêÊú¨ÁõëÊéßÂíåÈ¢ÑË≠¶Êú∫Âà∂", "status": "completed", "activeForm": "ÂÆåÂñÑÊàêÊú¨ÁõëÊéßÂíåÈ¢ÑË≠¶Êú∫Âà∂"}, {"content": "Â¢ûÂä†Êï∞ÊçÆËøÅÁßªÂíåÁâàÊú¨ÊéßÂà∂Á≠ñÁï•", "status": "in_progress", "activeForm": "Â¢ûÂä†Êï∞ÊçÆËøÅÁßªÂíåÁâàÊú¨ÊéßÂà∂Á≠ñÁï•"}, {"content": "Ê∑ªÂä†APIÁâàÊú¨ÊéßÂà∂Á≠ñÁï•", "status": "pending", "activeForm": "Ê∑ªÂä†APIÁâàÊú¨ÊéßÂà∂Á≠ñÁï•"}, {"content": "Â¢ûÂº∫‰∏öÂä°Â±ÇÈù¢ÁõëÊéßÊåáÊ†á", "status": "pending", "activeForm": "Â¢ûÂº∫‰∏öÂä°Â±ÇÈù¢ÁõëÊéßÊåáÊ†á"}, {"content": "‰ºòÂåñÂø´ÈÄüÂºÄÂßãÊåáÂçó", "status": "pending", "activeForm": "‰ºòÂåñÂø´ÈÄüÂºÄÂßãÊåáÂçó"}]